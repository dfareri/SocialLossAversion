
'
'	E:\Backup Data\SocialLossAversion\SLA_v1a_withpractice_FriendNew_8_11_16_ORDER2.ebs2
'	Generated on: 8/15/2018	10:50:58
'
'
'	This experiment has been generated with E-Prime version: 2.0.10.356
'
'	This file generated with E-Studio interface.
'	E-Prime Copyright Â© 1996-2015 Psychology Software Tools.
'	ALL RIGHTS RESERVED
'
'	Legal use of this experiment script requires a full E-Prime or Runtime License.
'
'
'
'
'
'

Option CStrings On
Dim ebContext as Context


'--------------------------------------------------------------------------
' Class Declarations
'--------------------------------------------------------------------------









































'--------------------------------------------------------------------------
' Instance Declarations
'--------------------------------------------------------------------------
Dim Display As DisplayDevice
Dim Keyboard As KeyboardDevice
Dim Mouse As MouseDevice
Dim Sound As SoundDevice
Dim ParallelPort As ParallelPortDevice
Dim SessionProc As Procedure
Dim SessionProc_nObject As Long
Dim SessionProc_bCanExit As Boolean
Dim SessionProc_theCollection As RteCollection
Dim SessionProc_theInputObject As RteRunnableInputObject

' List Attribute Constants
Const attrib_weight = ebUCase_W & ebLCase_e & ebLCase_i & ebLCase_g & ebLCase_h & ebLCase_t
Const attrib_nested = ebUCase_N & ebLCase_e & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_d
Const attrib_procedure = ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_d & ebLCase_u & ebLCase_r & ebLCase_e
Const attrib_amount1 = ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_1
Const attrib_amount2 = ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_2
Const attrib_certain = ebUCase_C & ebLCase_e & ebLCase_r & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n
Const attrib_gambleoutcome = ebUCase_G & ebLCase_a & ebLCase_m & ebLCase_b & ebLCase_l & ebLCase_e & ebUCase_O & ebLCase_u & ebLCase_t & ebLCase_c & ebLCase_o & ebLCase_m & ebLCase_e
Const attrib_gambleamount = ebUCase_G & ebLCase_a & ebLCase_m & ebLCase_b & ebLCase_l & ebLCase_e & ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t
Const attrib_partnername = ebUCase_P & ebLCase_a & ebLCase_r & ebLCase_t & ebLCase_n & ebLCase_e & ebLCase_r & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e
Const attrib_ratingoutcome = ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebUCase_O & ebLCase_u & ebLCase_t & ebLCase_c & ebLCase_o & ebLCase_m & ebLCase_e
Const attrib_itilength = ebUCase_I & ebUCase_T & ebUCase_I & ebLCase_l & ebLCase_e & ebLCase_n & ebLCase_g & ebLCase_t & ebLCase_h

Dim List1 As List

Dim Instructions As Procedure
Dim Instructions_nObject As Long
Dim Instructions_bCanExit As Boolean
Dim Instructions_theCollection As RteCollection
Dim Instructions_theInputObject As RteRunnableInputObject

Dim Ratings As Procedure
Dim Ratings_nObject As Long
Dim Ratings_bCanExit As Boolean
Dim Ratings_theCollection As RteCollection
Dim Ratings_theInputObject As RteRunnableInputObject

Dim SelfTask As Procedure
Dim SelfTask_nObject As Long
Dim SelfTask_bCanExit As Boolean
Dim SelfTask_theCollection As RteCollection
Dim SelfTask_theInputObject As RteRunnableInputObject

Dim OtherTask As Procedure
Dim OtherTask_nObject As Long
Dim OtherTask_bCanExit As Boolean
Dim OtherTask_theCollection As RteCollection
Dim OtherTask_theInputObject As RteRunnableInputObject

Dim BothTask As Procedure
Dim BothTask_nObject As Long
Dim BothTask_bCanExit As Boolean
Dim BothTask_theCollection As RteCollection
Dim BothTask_theInputObject As RteRunnableInputObject

Dim ITI As TextDisplay

Dim Options As Slide
Dim Options_State As SlideState
Dim Options_SlideText As SlideText

Dim ISI As TextDisplay

Dim Response As Slide
Dim ResponseEchoClients As EchoClientCollection
Dim Response_State As SlideState
Dim Response_SlideText As SlideText

Dim BothFB As FeedbackDisplay
Dim BothFB_State As SlideState
Dim BothFB_SlideText As SlideText
Dim BothFB_Child As RteRunnableInputObject
Dim BothFB_ChildIterator As Long
Dim BothFB_MaskIterator As Long
Dim BothFB_Mask As InputMask

Dim LASelfMixed As Procedure
Dim LASelfMixed_nObject As Long
Dim LASelfMixed_bCanExit As Boolean
Dim LASelfMixed_theCollection As RteCollection
Dim LASelfMixed_theInputObject As RteRunnableInputObject

Dim LASelfGain As Procedure
Dim LASelfGain_nObject As Long
Dim LASelfGain_bCanExit As Boolean
Dim LASelfGain_theCollection As RteCollection
Dim LASelfGain_theInputObject As RteRunnableInputObject

Dim List3 As List

Dim Self1 As Procedure
Dim Self1_nObject As Long
Dim Self1_bCanExit As Boolean
Dim Self1_theCollection As RteCollection
Dim Self1_theInputObject As RteRunnableInputObject

Dim Self2 As Procedure
Dim Self2_nObject As Long
Dim Self2_bCanExit As Boolean
Dim Self2_theCollection As RteCollection
Dim Self2_theInputObject As RteRunnableInputObject

Dim Self3 As Procedure
Dim Self3_nObject As Long
Dim Self3_bCanExit As Boolean
Dim Self3_theCollection As RteCollection
Dim Self3_theInputObject As RteRunnableInputObject

Dim List4 As List

Dim List5 As List

Dim List6 As List

Dim Instructions1 As TextDisplay
Dim Instructions1EchoClients As EchoClientCollection

Dim Instruction2 As TextDisplay
Dim Instruction2EchoClients As EchoClientCollection

Dim List2 As List

Dim List7 As List

Dim List8 As List

Dim Other1 As Procedure
Dim Other1_nObject As Long
Dim Other1_bCanExit As Boolean
Dim Other1_theCollection As RteCollection
Dim Other1_theInputObject As RteRunnableInputObject

Dim Other2 As Procedure
Dim Other2_nObject As Long
Dim Other2_bCanExit As Boolean
Dim Other2_theCollection As RteCollection
Dim Other2_theInputObject As RteRunnableInputObject

Dim Other3 As Procedure
Dim Other3_nObject As Long
Dim Other3_bCanExit As Boolean
Dim Other3_theCollection As RteCollection
Dim Other3_theInputObject As RteRunnableInputObject

Dim List9 As List

Dim List10 As List

Dim Both1 As Procedure
Dim Both1_nObject As Long
Dim Both1_bCanExit As Boolean
Dim Both1_theCollection As RteCollection
Dim Both1_theInputObject As RteRunnableInputObject

Dim Both2 As Procedure
Dim Both2_nObject As Long
Dim Both2_bCanExit As Boolean
Dim Both2_theCollection As RteCollection
Dim Both2_theInputObject As RteRunnableInputObject

Dim Both3 As Procedure
Dim Both3_nObject As Long
Dim Both3_bCanExit As Boolean
Dim Both3_theCollection As RteCollection
Dim Both3_theInputObject As RteRunnableInputObject

Dim List11 As List

Dim List12 As List

Dim List13 As List

Dim LAOtherMixed As Procedure
Dim LAOtherMixed_nObject As Long
Dim LAOtherMixed_bCanExit As Boolean
Dim LAOtherMixed_theCollection As RteCollection
Dim LAOtherMixed_theInputObject As RteRunnableInputObject

Dim LAOtherGain As Procedure
Dim LAOtherGain_nObject As Long
Dim LAOtherGain_bCanExit As Boolean
Dim LAOtherGain_theCollection As RteCollection
Dim LAOtherGain_theInputObject As RteRunnableInputObject

Dim LABothMixed As Procedure
Dim LABothMixed_nObject As Long
Dim LABothMixed_bCanExit As Boolean
Dim LABothMixed_theCollection As RteCollection
Dim LABothMixed_theInputObject As RteRunnableInputObject

Dim LABothGain As Procedure
Dim LABothGain_nObject As Long
Dim LABothGain_bCanExit As Boolean
Dim LABothGain_theCollection As RteCollection
Dim LABothGain_theInputObject As RteRunnableInputObject

Dim InstructionOptions1 As Slide
Dim InstructionOptions1EchoClients As EchoClientCollection
Dim InstructionOptions1_State As SlideState
Dim InstructionOptions1_SlideText As SlideText

Dim InstructionResponse2 As Slide
Dim InstructionResponse2EchoClients As EchoClientCollection
Dim InstructionResponse2_State As SlideState
Dim InstructionResponse2_SlideText As SlideText

Dim Instruction5 As TextDisplay
Dim Instruction5EchoClients As EchoClientCollection

Dim Instruction6 As TextDisplay
Dim Instruction6EchoClients As EchoClientCollection

Dim Instruction7 As TextDisplay
Dim Instruction7EchoClients As EchoClientCollection

Dim Instruction8 As TextDisplay
Dim Instruction8EchoClients As EchoClientCollection

Dim Instruction9 As TextDisplay
Dim Instruction9EchoClients As EchoClientCollection

Dim practiceoptions As Slide
Dim practiceoptions_State As SlideState
Dim practiceoptions_SlideText As SlideText

Dim practiceresponse As Slide
Dim practiceresponseEchoClients As EchoClientCollection
Dim practiceresponse_State As SlideState
Dim practiceresponse_SlideText As SlideText

Dim practiceresponse3 As Slide
Dim practiceresponse3EchoClients As EchoClientCollection
Dim practiceresponse3_State As SlideState
Dim practiceresponse3_SlideText As SlideText

Dim practiceoptions3 As Slide
Dim practiceoptions3_State As SlideState
Dim practiceoptions3_SlideText As SlideText

Dim PracticeList As List

Dim PracticeTrials As Procedure
Dim PracticeTrials_nObject As Long
Dim PracticeTrials_bCanExit As Boolean
Dim PracticeTrials_theCollection As RteCollection
Dim PracticeTrials_theInputObject As RteRunnableInputObject

Dim List14 As List

Dim PracticeMixed As Procedure
Dim PracticeMixed_nObject As Long
Dim PracticeMixed_bCanExit As Boolean
Dim PracticeMixed_theCollection As RteCollection
Dim PracticeMixed_theInputObject As RteRunnableInputObject

Dim PracticeGain As Procedure
Dim PracticeGain_nObject As Long
Dim PracticeGain_bCanExit As Boolean
Dim PracticeGain_theCollection As RteCollection
Dim PracticeGain_theInputObject As RteRunnableInputObject

Dim FeedbackDisplay2 As FeedbackDisplay
Dim FeedbackDisplay2_State As SlideState
Dim FeedbackDisplay2_SlideText As SlideText
Dim FeedbackDisplay2_Child As RteRunnableInputObject
Dim FeedbackDisplay2_ChildIterator As Long
Dim FeedbackDisplay2_MaskIterator As Long
Dim FeedbackDisplay2_Mask As InputMask

Dim FeedbackDisplay4 As FeedbackDisplay
Dim FeedbackDisplay4_State As SlideState
Dim FeedbackDisplay4_SlideText As SlideText
Dim FeedbackDisplay4_Child As RteRunnableInputObject
Dim FeedbackDisplay4_ChildIterator As Long
Dim FeedbackDisplay4_MaskIterator As Long
Dim FeedbackDisplay4_Mask As InputMask

Dim SelfSpaceBar1 As TextDisplay
Dim SelfSpaceBar1EchoClients As EchoClientCollection

Dim SelfSpaceBar2 As TextDisplay
Dim SelfSpaceBar2EchoClients As EchoClientCollection

Dim SelfSpaceBar3 As TextDisplay
Dim SelfSpaceBar3EchoClients As EchoClientCollection

Dim OtherSpaceBar1 As TextDisplay
Dim OtherSpaceBar1EchoClients As EchoClientCollection

Dim OtherSpaceBar2 As TextDisplay
Dim OtherSpaceBar2EchoClients As EchoClientCollection

Dim BothSpaceBar1 As TextDisplay
Dim BothSpaceBar1EchoClients As EchoClientCollection

Dim OtherSpaceBar3 As TextDisplay
Dim OtherSpaceBar3EchoClients As EchoClientCollection

Dim BothSpaceBar2 As TextDisplay
Dim BothSpaceBar2EchoClients As EchoClientCollection

Dim BothSpaceBar3 As TextDisplay
Dim BothSpaceBar3EchoClients As EchoClientCollection

Dim OtherBlockInstructions As Slide
Dim OtherBlockInstructionsEchoClients As EchoClientCollection
Dim OtherBlockInstructions_State As SlideState
Dim OtherBlockInstructions_SlideText As SlideText

Dim BothBlockInstructions As Slide
Dim BothBlockInstructionsEchoClients As EchoClientCollection
Dim BothBlockInstructions_State As SlideState
Dim BothBlockInstructions_SlideText As SlideText

Dim OtherFB As FeedbackDisplay
Dim OtherFB_State As SlideState
Dim OtherFB_SlideText As SlideText
Dim OtherFB_Child As RteRunnableInputObject
Dim OtherFB_ChildIterator As Long
Dim OtherFB_MaskIterator As Long
Dim OtherFB_Mask As InputMask

Dim SelfFB As FeedbackDisplay
Dim SelfFB_State As SlideState
Dim SelfFB_SlideText As SlideText
Dim SelfFB_Child As RteRunnableInputObject
Dim SelfFB_ChildIterator As Long
Dim SelfFB_MaskIterator As Long
Dim SelfFB_Mask As InputMask

Dim thanksforplaying As TextDisplay
Dim thanksforplayingEchoClients As EchoClientCollection

Dim RatingsList As List

Dim selfratings As Procedure
Dim selfratings_nObject As Long
Dim selfratings_bCanExit As Boolean
Dim selfratings_theCollection As RteCollection
Dim selfratings_theInputObject As RteRunnableInputObject

Dim otherratings As Procedure
Dim otherratings_nObject As Long
Dim otherratings_bCanExit As Boolean
Dim otherratings_theCollection As RteCollection
Dim otherratings_theInputObject As RteRunnableInputObject

Dim sharedratings As Procedure
Dim sharedratings_nObject As Long
Dim sharedratings_bCanExit As Boolean
Dim sharedratings_theCollection As RteCollection
Dim sharedratings_theInputObject As RteRunnableInputObject

Dim SelfOutcomes As Slide
Dim SelfOutcomesEchoClients As EchoClientCollection
Dim SelfOutcomes_State As SlideState
Dim SelfOutcomes_SlideText As SlideText

Dim OtherOutcomes As Slide
Dim OtherOutcomesEchoClients As EchoClientCollection
Dim OtherOutcomes_State As SlideState
Dim OtherOutcomes_SlideText As SlideText

Dim SharedOutcomes As Slide
Dim SharedOutcomesEchoClients As EchoClientCollection
Dim SharedOutcomes_State As SlideState
Dim SharedOutcomes_SlideText As SlideText

Dim pleasenotify As TextDisplay
Dim pleasenotifyEchoClients As EchoClientCollection

Dim ITIList As List

Dim ITIPrac As TextDisplay



'--------------------------------------------------------------------------
' Package Declare Script
'--------------------------------------------------------------------------



'--------------------------------------------------------------------------
' User Script - BEGIN
'--------------------------------------------------------------------------


'--------------------------------------------------------------------------
' User Script - END
'--------------------------------------------------------------------------



'--------------------------------------------------------------------------
' Package Global Script
'--------------------------------------------------------------------------



'--------------------------------------------------------------------------
' Implementation
'--------------------------------------------------------------------------
Sub SessionProc_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		List1.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'
	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		'NOTE: This Procedure is the root procedure in the Experiment Object.
		'  No script generated here for Object.InputMasks.IsPending()

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop
	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Instructions_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Instructions1.ResetLoggingProperties
		Instruction2.ResetLoggingProperties
		InstructionOptions1.ResetLoggingProperties
		InstructionResponse2.ResetLoggingProperties
		Instruction5.ResetLoggingProperties
		Instruction7.ResetLoggingProperties
		Instruction8.ResetLoggingProperties
		Instruction9.ResetLoggingProperties







	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	Instructions1.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		Instructions1EchoClients.RemoveAll
		Instructions1.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_A & ebUCase_N & ebUCase_Y & ebBraceClose, ebEmptyText, CLng(Instructions1.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	Instructions1.Run
	c.SetAttrib Instructions1.Name & ebDot & ebLogNameOnsetDelay, Instructions1.OnsetDelay
	c.SetAttrib Instructions1.Name & ebDot & ebLogNameOnsetTime, Instructions1.OnsetTime
	c.SetAttrib Instructions1.Name & ebDot & ebLogNameDurationError, Instructions1.DurationError
	c.SetAttrib Instructions1.Name & ebDot & ebLogNameRTTime, Instructions1.RTTime
	c.SetAttrib Instructions1.Name & ebDot & ebLogNameACC, Instructions1.ACC
	c.SetAttrib Instructions1.Name & ebDot & ebLogNameRT, Instructions1.RT
	c.SetAttrib Instructions1.Name & ebDot & ebLogNameRESP, Instructions1.RESP
	c.SetAttrib Instructions1.Name & ebDot & ebLogNameCRESP, Instructions1.CRESP
	c.SetAttrib Instructions1.Name & ebDot & ebLogNameOnsetToOnsetTime, Instructions1.OnsetToOnsetTime



	Instruction2.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		Instruction2EchoClients.RemoveAll
		Instruction2.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_A & ebUCase_N & ebUCase_Y & ebBraceClose, ebEmptyText, CLng(Instruction2.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	Instruction2.Run
	c.SetAttrib Instruction2.Name & ebDot & ebLogNameOnsetDelay, Instruction2.OnsetDelay
	c.SetAttrib Instruction2.Name & ebDot & ebLogNameOnsetTime, Instruction2.OnsetTime
	c.SetAttrib Instruction2.Name & ebDot & ebLogNameDurationError, Instruction2.DurationError
	c.SetAttrib Instruction2.Name & ebDot & ebLogNameRTTime, Instruction2.RTTime
	c.SetAttrib Instruction2.Name & ebDot & ebLogNameACC, Instruction2.ACC
	c.SetAttrib Instruction2.Name & ebDot & ebLogNameRT, Instruction2.RT
	c.SetAttrib Instruction2.Name & ebDot & ebLogNameRESP, Instruction2.RESP
	c.SetAttrib Instruction2.Name & ebDot & ebLogNameCRESP, Instruction2.CRESP
	c.SetAttrib Instruction2.Name & ebDot & ebLogNameOnsetToOnsetTime, Instruction2.OnsetToOnsetTime



	InstructionOptions1.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		InstructionOptions1EchoClients.RemoveAll
		InstructionOptions1.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_A & ebUCase_N & ebUCase_Y & ebBraceClose, ebEmptyText, CLng(InstructionOptions1.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	InstructionOptions1.Run



	InstructionResponse2.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		InstructionResponse2EchoClients.RemoveAll
		InstructionResponse2.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_A & ebUCase_N & ebUCase_Y & ebBraceClose, ebEmptyText, CLng(InstructionResponse2.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	InstructionResponse2.Run



	Instruction5.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		Instruction5EchoClients.RemoveAll
		Instruction5.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_A & ebUCase_N & ebUCase_Y & ebBraceClose, ebEmptyText, CLng(Instruction5.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	Instruction5.Run


	Instruction7.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		Instruction7EchoClients.RemoveAll
		Instruction7.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_A & ebUCase_N & ebUCase_Y & ebBraceClose, ebEmptyText, CLng(Instruction7.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	Instruction7.Run


	Instruction8.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		Instruction8EchoClients.RemoveAll
		Instruction8.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_A & ebUCase_N & ebUCase_Y & ebBraceClose, ebEmptyText, CLng(Instruction8.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	Instruction8.Run
		PracticeList.Run c


	Instruction9.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		Instruction9EchoClients.RemoveAll
		Instruction9.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_A & ebUCase_N & ebUCase_Y & ebBraceClose, ebEmptyText, CLng(Instruction9.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	Instruction9.Run
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Instructions_theCollection.RemoveAll
	For Instructions_nObject = 1 To Instructions.ChildObjectCount
		Set Instructions_theInputObject = CRteRunnableInputObject(Rte.GetObject(Instructions.GetChildObjectName(Instructions_nObject)))
		If Not Instructions_theInputObject Is Nothing Then Instructions_theCollection.Add Instructions_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Instructions_bCanExit = True
		For Instructions_nObject = 1 To Instructions_theCollection.Count
			Set Instructions_theInputObject = CRteRunnableInputObject(Instructions_theCollection(Instructions_nObject))
			If Not Instructions_theInputObject Is Nothing Then
				If Instructions_theInputObject.InputMasks.IsPending() Then
					Instructions_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Instructions_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Instructions_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Instructions1.EndOfProcedure

	Instruction2.EndOfProcedure

	InstructionOptions1.EndOfProcedure

	InstructionResponse2.EndOfProcedure

	Instruction5.EndOfProcedure

	Instruction7.EndOfProcedure

	Instruction8.EndOfProcedure

	Instruction9.EndOfProcedure

	c.SetAttrib Instructions1.Name & ebDot & ebLogNameOnsetDelay, Instructions1.OnsetDelay
	c.SetAttrib Instructions1.Name & ebDot & ebLogNameOnsetTime, Instructions1.OnsetTime
	c.SetAttrib Instructions1.Name & ebDot & ebLogNameDurationError, Instructions1.DurationError
	c.SetAttrib Instructions1.Name & ebDot & ebLogNameRTTime, Instructions1.RTTime
	c.SetAttrib Instructions1.Name & ebDot & ebLogNameACC, Instructions1.ACC
	c.SetAttrib Instructions1.Name & ebDot & ebLogNameRT, Instructions1.RT
	c.SetAttrib Instructions1.Name & ebDot & ebLogNameRESP, Instructions1.RESP
	c.SetAttrib Instructions1.Name & ebDot & ebLogNameCRESP, Instructions1.CRESP
	c.SetAttrib Instructions1.Name & ebDot & ebLogNameOnsetToOnsetTime, Instructions1.OnsetToOnsetTime

	c.SetAttrib Instruction2.Name & ebDot & ebLogNameOnsetDelay, Instruction2.OnsetDelay
	c.SetAttrib Instruction2.Name & ebDot & ebLogNameOnsetTime, Instruction2.OnsetTime
	c.SetAttrib Instruction2.Name & ebDot & ebLogNameDurationError, Instruction2.DurationError
	c.SetAttrib Instruction2.Name & ebDot & ebLogNameRTTime, Instruction2.RTTime
	c.SetAttrib Instruction2.Name & ebDot & ebLogNameACC, Instruction2.ACC
	c.SetAttrib Instruction2.Name & ebDot & ebLogNameRT, Instruction2.RT
	c.SetAttrib Instruction2.Name & ebDot & ebLogNameRESP, Instruction2.RESP
	c.SetAttrib Instruction2.Name & ebDot & ebLogNameCRESP, Instruction2.CRESP
	c.SetAttrib Instruction2.Name & ebDot & ebLogNameOnsetToOnsetTime, Instruction2.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Ratings_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	thanksforplaying.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		thanksforplayingEchoClients.RemoveAll
		thanksforplaying.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_A & ebUCase_N & ebUCase_Y & ebBraceClose, ebEmptyText, CLng(thanksforplaying.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	thanksforplaying.Run
		RatingsList.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Ratings_theCollection.RemoveAll
	For Ratings_nObject = 1 To Ratings.ChildObjectCount
		Set Ratings_theInputObject = CRteRunnableInputObject(Rte.GetObject(Ratings.GetChildObjectName(Ratings_nObject)))
		If Not Ratings_theInputObject Is Nothing Then Ratings_theCollection.Add Ratings_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Ratings_bCanExit = True
		For Ratings_nObject = 1 To Ratings_theCollection.Count
			Set Ratings_theInputObject = CRteRunnableInputObject(Ratings_theCollection(Ratings_nObject))
			If Not Ratings_theInputObject Is Nothing Then
				If Ratings_theInputObject.InputMasks.IsPending() Then
					Ratings_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Ratings_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Ratings_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	thanksforplaying.EndOfProcedure


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub SelfTask_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - InLine1 BEGIN <InLine1>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,10
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - InLine1 END
	'''''''''''''''''''''''''''''''''''''''''''''

		List3.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	SelfTask_theCollection.RemoveAll
	For SelfTask_nObject = 1 To SelfTask.ChildObjectCount
		Set SelfTask_theInputObject = CRteRunnableInputObject(Rte.GetObject(SelfTask.GetChildObjectName(SelfTask_nObject)))
		If Not SelfTask_theInputObject Is Nothing Then SelfTask_theCollection.Add SelfTask_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		SelfTask_bCanExit = True
		For SelfTask_nObject = 1 To SelfTask_theCollection.Count
			Set SelfTask_theInputObject = CRteRunnableInputObject(SelfTask_theCollection(SelfTask_nObject))
			If Not SelfTask_theInputObject Is Nothing Then
				If SelfTask_theInputObject.InputMasks.IsPending() Then
					SelfTask_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If SelfTask_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	SelfTask_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub OtherTask_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		OtherBlockInstructions.ResetLoggingProperties

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	OtherBlockInstructions.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		OtherBlockInstructionsEchoClients.RemoveAll
		OtherBlockInstructions.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, ebEmptyText, CLng(OtherBlockInstructions.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	OtherBlockInstructions.Run

		List2.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	OtherTask_theCollection.RemoveAll
	For OtherTask_nObject = 1 To OtherTask.ChildObjectCount
		Set OtherTask_theInputObject = CRteRunnableInputObject(Rte.GetObject(OtherTask.GetChildObjectName(OtherTask_nObject)))
		If Not OtherTask_theInputObject Is Nothing Then OtherTask_theCollection.Add OtherTask_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		OtherTask_bCanExit = True
		For OtherTask_nObject = 1 To OtherTask_theCollection.Count
			Set OtherTask_theInputObject = CRteRunnableInputObject(OtherTask_theCollection(OtherTask_nObject))
			If Not OtherTask_theInputObject Is Nothing Then
				If OtherTask_theInputObject.InputMasks.IsPending() Then
					OtherTask_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If OtherTask_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	OtherTask_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	OtherBlockInstructions.EndOfProcedure


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub BothTask_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		BothBlockInstructions.ResetLoggingProperties
		pleasenotify.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	BothBlockInstructions.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		BothBlockInstructionsEchoClients.RemoveAll
		BothBlockInstructions.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_A & ebUCase_N & ebUCase_Y & ebBraceClose, ebEmptyText, CLng(BothBlockInstructions.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	BothBlockInstructions.Run

	c.SetAttrib BothBlockInstructions.Name & ebDot & ebLogNameOnsetDelay, BothBlockInstructions.OnsetDelay
	c.SetAttrib BothBlockInstructions.Name & ebDot & ebLogNameOnsetTime, BothBlockInstructions.OnsetTime
	c.SetAttrib BothBlockInstructions.Name & ebDot & ebLogNameDurationError, BothBlockInstructions.DurationError
	c.SetAttrib BothBlockInstructions.Name & ebDot & ebLogNameRTTime, BothBlockInstructions.RTTime
	c.SetAttrib BothBlockInstructions.Name & ebDot & ebLogNameACC, BothBlockInstructions.ACC
	c.SetAttrib BothBlockInstructions.Name & ebDot & ebLogNameRT, BothBlockInstructions.RT
	c.SetAttrib BothBlockInstructions.Name & ebDot & ebLogNameRESP, BothBlockInstructions.RESP
	c.SetAttrib BothBlockInstructions.Name & ebDot & ebLogNameCRESP, BothBlockInstructions.CRESP
	c.SetAttrib BothBlockInstructions.Name & ebDot & ebLogNameOnsetToOnsetTime, BothBlockInstructions.OnsetToOnsetTime

		List10.Run c


	pleasenotify.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		pleasenotifyEchoClients.RemoveAll
		pleasenotify.InputMasks.Add Keyboard.CreateInputMask(ebLCase_z, ebEmptyText, CLng(pleasenotify.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	pleasenotify.Run
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	BothTask_theCollection.RemoveAll
	For BothTask_nObject = 1 To BothTask.ChildObjectCount
		Set BothTask_theInputObject = CRteRunnableInputObject(Rte.GetObject(BothTask.GetChildObjectName(BothTask_nObject)))
		If Not BothTask_theInputObject Is Nothing Then BothTask_theCollection.Add BothTask_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		BothTask_bCanExit = True
		For BothTask_nObject = 1 To BothTask_theCollection.Count
			Set BothTask_theInputObject = CRteRunnableInputObject(BothTask_theCollection(BothTask_nObject))
			If Not BothTask_theInputObject Is Nothing Then
				If BothTask_theInputObject.InputMasks.IsPending() Then
					BothTask_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If BothTask_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	BothTask_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	BothBlockInstructions.EndOfProcedure

	pleasenotify.EndOfProcedure

	c.SetAttrib BothBlockInstructions.Name & ebDot & ebLogNameOnsetDelay, BothBlockInstructions.OnsetDelay
	c.SetAttrib BothBlockInstructions.Name & ebDot & ebLogNameOnsetTime, BothBlockInstructions.OnsetTime
	c.SetAttrib BothBlockInstructions.Name & ebDot & ebLogNameDurationError, BothBlockInstructions.DurationError
	c.SetAttrib BothBlockInstructions.Name & ebDot & ebLogNameRTTime, BothBlockInstructions.RTTime
	c.SetAttrib BothBlockInstructions.Name & ebDot & ebLogNameACC, BothBlockInstructions.ACC
	c.SetAttrib BothBlockInstructions.Name & ebDot & ebLogNameRT, BothBlockInstructions.RT
	c.SetAttrib BothBlockInstructions.Name & ebDot & ebLogNameRESP, BothBlockInstructions.RESP
	c.SetAttrib BothBlockInstructions.Name & ebDot & ebLogNameCRESP, BothBlockInstructions.CRESP
	c.SetAttrib BothBlockInstructions.Name & ebDot & ebLogNameOnsetToOnsetTime, BothBlockInstructions.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub







Sub LASelfMixed_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Options.ResetLoggingProperties
		Response.ResetLoggingProperties
		ISI.ResetLoggingProperties
		ITI.ResetLoggingProperties
		Select Case Options.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t


			'Text4
			Set Options_SlideText = CSlideText(Options.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_4))
			Options_SlideText.Text = c.GetAttrib(ebUCase_C & ebLCase_e & ebLCase_r & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n)
			Set Options_SlideText = Nothing

			'Text2
			Set Options_SlideText = CSlideText(Options.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_2))
			Options_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_2)
			Set Options_SlideText = Nothing

			'Text1
			Set Options_SlideText = CSlideText(Options.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			Options_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_1)
			Set Options_SlideText = Nothing

	End Select

		Select Case Response.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t


			'Text3
			Set Response_SlideText = CSlideText(Response.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_3))
			Response_SlideText.Text = c.GetAttrib(ebUCase_C & ebLCase_e & ebLCase_r & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n)
			Set Response_SlideText = Nothing

			'Text2
			Set Response_SlideText = CSlideText(Response.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_2))
			Response_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_2)
			Set Response_SlideText = Nothing

			'Text1
			Set Response_SlideText = CSlideText(Response.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			Response_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_1)
			Set Response_SlideText = Nothing

	End Select




	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn BEGIN <PulseOn>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn END
	'''''''''''''''''''''''''''''''''''''''''''''


	Options.Run

	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetDelay, Options.OnsetDelay
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetTime, Options.OnsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameDurationError, Options.DurationError
	c.SetAttrib Options.Name & ebDot & ebLogNameDuration, Options.Duration
	c.SetAttrib Options.Name & ebDot & ebLogNameOffsetTime, Options.OffsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameRTTime, Options.RTTime
	c.SetAttrib Options.Name & ebDot & ebLogNameACC, Options.ACC
	c.SetAttrib Options.Name & ebDot & ebLogNameRT, Options.RT
	c.SetAttrib Options.Name & ebDot & ebLogNameRESP, Options.RESP
	c.SetAttrib Options.Name & ebDot & ebLogNameCRESP, Options.CRESP
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetToOnsetTime, Options.OnsetToOnsetTime



	Response.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		ResponseEchoClients.RemoveAll
		Response.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1 & ebDigit_2, ebDigit_1, CLng(Response.Duration), CLng(ebDigit_1), ebEndResponseActionNone, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	Response.Run

	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetDelay, Response.OnsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetTime, Response.OnsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameDurationError, Response.DurationError
	c.SetAttrib Response.Name & ebDot & ebLogNameDuration, Response.Duration
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetTime, Response.OffsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetDelay, Response.OffsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameRTTime, Response.RTTime
	c.SetAttrib Response.Name & ebDot & ebLogNameACC, Response.ACC
	c.SetAttrib Response.Name & ebDot & ebLogNameRT, Response.RT
	c.SetAttrib Response.Name & ebDot & ebLogNameRESP, Response.RESP
	c.SetAttrib Response.Name & ebDot & ebLogNameCRESP, Response.CRESP
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetToOnsetTime, Response.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff BEGIN <PulseOff>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff END
	'''''''''''''''''''''''''''''''''''''''''''''


	ISI.Run
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetDelay, ISI.OnsetDelay
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetTime, ISI.OnsetTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameDurationError, ISI.DurationError
	c.SetAttrib ISI.Name & ebDot & ebLogNameRTTime, ISI.RTTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameACC, ISI.ACC
	c.SetAttrib ISI.Name & ebDot & ebLogNameRT, ISI.RT
	c.SetAttrib ISI.Name & ebDot & ebLogNameRESP, ISI.RESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameCRESP, ISI.CRESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetToOnsetTime, ISI.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn1 BEGIN <PulseOn1>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn1 END
	'''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Feedback_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Feedback_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Feedback_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing the input object pending any input masks.
	' To prevent this code from being generated, set the Feedback object's
	'.ProcessInputObjectPendingInputMasks property to No/False.
	'
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		'Input Masks still pending?
		If Not Response.InputMasks.IsPending() Then
			Exit Do
		End If

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop
	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	'Determine if there are any InputMasks with a ebTimeLimitUntilFeedback set
	For SelfFB_ChildIterator = 1 To LASelfMixed.ChildObjectCount
		Set SelfFB_Child = CRteRunnableInputObject(Rte.GetObject(LASelfMixed.GetChildObjectName(SelfFB_ChildIterator)))
		If Not SelfFB_Child Is Nothing Then

			'Have we reached this FeedbackDisplay?
			'(we do not terminate InputMask with ebTimeLimitUntilFeedback
			'  that occur after our FeedbackDisplay)
			If SelfFB_Child.Name = SelfFB.Name Then Exit For

			'Enumerate through each object and then through each InputMask
			'terminate any input masks that have ebTimeLimitUntilFeeback set
			For SelfFB_MaskIterator = 1 To SelfFB_Child.InputMasks.Count
				Set SelfFB_Mask = SelfFB_Child.InputMasks(SelfFB_MaskIterator)
				If Not SelfFB_Mask Is Nothing Then
					If SelfFB_Mask.Status = ebStatusArmed Then
						If SelfFB_Mask.TimeLimit = ebTimeLimitUntilFeedback Then
							SelfFB_Mask.Terminate
						End If
					End If
				End If
			Next
		End If
	Next

	If Response.ACC = 1 Then
		'Set the ActiveState to Correct
		SelfFB.ActiveState = "Correct"

		'Add an observation to the accuracy stats
		SelfFB.AccStats.AddObservation Response.Acc

		'Add an observation to the response time stats
		' unless the user did not respond and the author
		' does not want us to add the no response RT
		If Len(Response.RESP) > 0 Then
			SelfFB.RTStats.AddObservation Response.RT
			SelfFB.CorrectRTStats.AddObservation Response.RT
		End If
	Else
		'Is it incorrect or no response?
		If Len(Response.RESP) > 0 Then
			'Set the ActiveState to Incorrect
			SelfFB.ActiveState = "Incorrect"

			'Set the accuracy stats
			SelfFB.AccStats.AddObservation Response.Acc

			'Set the RT stats
			SelfFB.RTStats.AddObservation Response.RT
			SelfFB.IncorrectRTStats.AddObservation Response.RT
		Else
			'Set the ActiveState to NoResponse
			SelfFB.ActiveState = "NoResponse"

			'Does the author want to consider a NoResponse
			' to sum as an incorrect response in the ACC stats?
			If SelfFB.CollectNoRespACCStats = True Then
				SelfFB.AccStats.AddObservation Response.Acc
			End If
		End If
	End If


	Select Case SelfFB.ActiveState
		Case ebUCase_C & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t


			'Text1
			Set SelfFB_SlideText = CSlideText(SelfFB.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			SelfFB_SlideText.Text = "You " &_
				c.GetAttrib("GambleOutcome") &_
				" " &_
				c.GetAttrib("GambleAmount")
			Set SelfFB_SlideText = Nothing

		Case ebUCase_I & ebLCase_n & ebLCase_c & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t


			'Text1
			Set SelfFB_SlideText = CSlideText(SelfFB.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			SelfFB_SlideText.Text = "You will receive the certain option of " &_
				c.GetAttrib("Certain")
			Set SelfFB_SlideText = Nothing

	End Select



	SelfFB.Run


	c.SetAttrib SelfFB.Name & ebDot & ebLogNameOnsetDelay, SelfFB.OnsetDelay
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameOnsetTime, SelfFB.OnsetTime
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameDurationError, SelfFB.DurationError
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameRTTime, SelfFB.RTTime
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameACC, SelfFB.ACC
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameRT, SelfFB.RT
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameRESP, SelfFB.RESP
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameCRESP, SelfFB.CRESP
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameOnsetToOnsetTime, SelfFB.OnsetToOnsetTime


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Feedback_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Feedback_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Feedback_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff1 BEGIN <PulseOff1>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff1 END
	'''''''''''''''''''''''''''''''''''''''''''''


	ITI.Duration = CLng(c.GetAttrib(ebUCase_I & ebUCase_T & ebUCase_I & ebLCase_l & ebLCase_e & ebLCase_n & ebLCase_g & ebLCase_t & ebLCase_h))
	ITI.Run
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetDelay, ITI.OnsetDelay
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetTime, ITI.OnsetTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameDurationError, ITI.DurationError
	c.SetAttrib ITI.Name & ebDot & ebLogNameRTTime, ITI.RTTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameACC, ITI.ACC
	c.SetAttrib ITI.Name & ebDot & ebLogNameRT, ITI.RT
	c.SetAttrib ITI.Name & ebDot & ebLogNameRESP, ITI.RESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameCRESP, ITI.CRESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetToOnsetTime, ITI.OnsetToOnsetTime

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	LASelfMixed_theCollection.RemoveAll
	For LASelfMixed_nObject = 1 To LASelfMixed.ChildObjectCount
		Set LASelfMixed_theInputObject = CRteRunnableInputObject(Rte.GetObject(LASelfMixed.GetChildObjectName(LASelfMixed_nObject)))
		If Not LASelfMixed_theInputObject Is Nothing Then LASelfMixed_theCollection.Add LASelfMixed_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		LASelfMixed_bCanExit = True
		For LASelfMixed_nObject = 1 To LASelfMixed_theCollection.Count
			Set LASelfMixed_theInputObject = CRteRunnableInputObject(LASelfMixed_theCollection(LASelfMixed_nObject))
			If Not LASelfMixed_theInputObject Is Nothing Then
				If LASelfMixed_theInputObject.InputMasks.IsPending() Then
					LASelfMixed_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If LASelfMixed_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	LASelfMixed_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Options.EndOfProcedure

	Response.EndOfProcedure

	ISI.EndOfProcedure

	SelfFB.EndOfProcedure

	ITI.EndOfProcedure

	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetDelay, Options.OnsetDelay
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetTime, Options.OnsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameDurationError, Options.DurationError
	c.SetAttrib Options.Name & ebDot & ebLogNameDuration, Options.Duration
	c.SetAttrib Options.Name & ebDot & ebLogNameOffsetTime, Options.OffsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameRTTime, Options.RTTime
	c.SetAttrib Options.Name & ebDot & ebLogNameACC, Options.ACC
	c.SetAttrib Options.Name & ebDot & ebLogNameRT, Options.RT
	c.SetAttrib Options.Name & ebDot & ebLogNameRESP, Options.RESP
	c.SetAttrib Options.Name & ebDot & ebLogNameCRESP, Options.CRESP
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetToOnsetTime, Options.OnsetToOnsetTime

	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetDelay, Response.OnsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetTime, Response.OnsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameDurationError, Response.DurationError
	c.SetAttrib Response.Name & ebDot & ebLogNameDuration, Response.Duration
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetTime, Response.OffsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetDelay, Response.OffsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameRTTime, Response.RTTime
	c.SetAttrib Response.Name & ebDot & ebLogNameACC, Response.ACC
	c.SetAttrib Response.Name & ebDot & ebLogNameRT, Response.RT
	c.SetAttrib Response.Name & ebDot & ebLogNameRESP, Response.RESP
	c.SetAttrib Response.Name & ebDot & ebLogNameCRESP, Response.CRESP
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetToOnsetTime, Response.OnsetToOnsetTime

	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetDelay, ISI.OnsetDelay
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetTime, ISI.OnsetTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameDurationError, ISI.DurationError
	c.SetAttrib ISI.Name & ebDot & ebLogNameRTTime, ISI.RTTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameACC, ISI.ACC
	c.SetAttrib ISI.Name & ebDot & ebLogNameRT, ISI.RT
	c.SetAttrib ISI.Name & ebDot & ebLogNameRESP, ISI.RESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameCRESP, ISI.CRESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetToOnsetTime, ISI.OnsetToOnsetTime

	c.SetAttrib SelfFB.Name & ebDot & ebLogNameOnsetDelay, SelfFB.OnsetDelay
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameOnsetTime, SelfFB.OnsetTime
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameDurationError, SelfFB.DurationError
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameRTTime, SelfFB.RTTime
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameACC, SelfFB.ACC
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameRT, SelfFB.RT
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameRESP, SelfFB.RESP
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameCRESP, SelfFB.CRESP
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameOnsetToOnsetTime, SelfFB.OnsetToOnsetTime

	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetDelay, ITI.OnsetDelay
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetTime, ITI.OnsetTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameDurationError, ITI.DurationError
	c.SetAttrib ITI.Name & ebDot & ebLogNameRTTime, ITI.RTTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameACC, ITI.ACC
	c.SetAttrib ITI.Name & ebDot & ebLogNameRT, ITI.RT
	c.SetAttrib ITI.Name & ebDot & ebLogNameRESP, ITI.RESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameCRESP, ITI.CRESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetToOnsetTime, ITI.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub LASelfGain_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Options.ResetLoggingProperties
		Response.ResetLoggingProperties
		ISI.ResetLoggingProperties
		ITI.ResetLoggingProperties
		Select Case Options.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t


			'Text4
			Set Options_SlideText = CSlideText(Options.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_4))
			Options_SlideText.Text = c.GetAttrib(ebUCase_C & ebLCase_e & ebLCase_r & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n)
			Set Options_SlideText = Nothing

			'Text2
			Set Options_SlideText = CSlideText(Options.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_2))
			Options_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_2)
			Set Options_SlideText = Nothing

			'Text1
			Set Options_SlideText = CSlideText(Options.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			Options_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_1)
			Set Options_SlideText = Nothing

	End Select

		Select Case Response.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t


			'Text3
			Set Response_SlideText = CSlideText(Response.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_3))
			Response_SlideText.Text = c.GetAttrib(ebUCase_C & ebLCase_e & ebLCase_r & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n)
			Set Response_SlideText = Nothing

			'Text2
			Set Response_SlideText = CSlideText(Response.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_2))
			Response_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_2)
			Set Response_SlideText = Nothing

			'Text1
			Set Response_SlideText = CSlideText(Response.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			Response_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_1)
			Set Response_SlideText = Nothing

	End Select




	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn BEGIN <PulseOn>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn END
	'''''''''''''''''''''''''''''''''''''''''''''


	Options.Run

	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetDelay, Options.OnsetDelay
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetTime, Options.OnsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameDurationError, Options.DurationError
	c.SetAttrib Options.Name & ebDot & ebLogNameDuration, Options.Duration
	c.SetAttrib Options.Name & ebDot & ebLogNameOffsetTime, Options.OffsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameRTTime, Options.RTTime
	c.SetAttrib Options.Name & ebDot & ebLogNameACC, Options.ACC
	c.SetAttrib Options.Name & ebDot & ebLogNameRT, Options.RT
	c.SetAttrib Options.Name & ebDot & ebLogNameRESP, Options.RESP
	c.SetAttrib Options.Name & ebDot & ebLogNameCRESP, Options.CRESP
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetToOnsetTime, Options.OnsetToOnsetTime



	Response.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		ResponseEchoClients.RemoveAll
		Response.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1 & ebDigit_2, ebDigit_1, CLng(Response.Duration), CLng(ebDigit_1), ebEndResponseActionNone, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	Response.Run

	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetDelay, Response.OnsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetTime, Response.OnsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameDurationError, Response.DurationError
	c.SetAttrib Response.Name & ebDot & ebLogNameDuration, Response.Duration
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetTime, Response.OffsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetDelay, Response.OffsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameRTTime, Response.RTTime
	c.SetAttrib Response.Name & ebDot & ebLogNameACC, Response.ACC
	c.SetAttrib Response.Name & ebDot & ebLogNameRT, Response.RT
	c.SetAttrib Response.Name & ebDot & ebLogNameRESP, Response.RESP
	c.SetAttrib Response.Name & ebDot & ebLogNameCRESP, Response.CRESP
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetToOnsetTime, Response.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff BEGIN <PulseOff>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff END
	'''''''''''''''''''''''''''''''''''''''''''''


	ISI.Run
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetDelay, ISI.OnsetDelay
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetTime, ISI.OnsetTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameDurationError, ISI.DurationError
	c.SetAttrib ISI.Name & ebDot & ebLogNameRTTime, ISI.RTTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameACC, ISI.ACC
	c.SetAttrib ISI.Name & ebDot & ebLogNameRT, ISI.RT
	c.SetAttrib ISI.Name & ebDot & ebLogNameRESP, ISI.RESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameCRESP, ISI.CRESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetToOnsetTime, ISI.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn1 BEGIN <PulseOn1>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn1 END
	'''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Feedback_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Feedback_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Feedback_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing the input object pending any input masks.
	' To prevent this code from being generated, set the Feedback object's
	'.ProcessInputObjectPendingInputMasks property to No/False.
	'
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		'Input Masks still pending?
		If Not Response.InputMasks.IsPending() Then
			Exit Do
		End If

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop
	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	'Determine if there are any InputMasks with a ebTimeLimitUntilFeedback set
	For SelfFB_ChildIterator = 1 To LASelfGain.ChildObjectCount
		Set SelfFB_Child = CRteRunnableInputObject(Rte.GetObject(LASelfGain.GetChildObjectName(SelfFB_ChildIterator)))
		If Not SelfFB_Child Is Nothing Then

			'Have we reached this FeedbackDisplay?
			'(we do not terminate InputMask with ebTimeLimitUntilFeedback
			'  that occur after our FeedbackDisplay)
			If SelfFB_Child.Name = SelfFB.Name Then Exit For

			'Enumerate through each object and then through each InputMask
			'terminate any input masks that have ebTimeLimitUntilFeeback set
			For SelfFB_MaskIterator = 1 To SelfFB_Child.InputMasks.Count
				Set SelfFB_Mask = SelfFB_Child.InputMasks(SelfFB_MaskIterator)
				If Not SelfFB_Mask Is Nothing Then
					If SelfFB_Mask.Status = ebStatusArmed Then
						If SelfFB_Mask.TimeLimit = ebTimeLimitUntilFeedback Then
							SelfFB_Mask.Terminate
						End If
					End If
				End If
			Next
		End If
	Next

	If Response.ACC = 1 Then
		'Set the ActiveState to Correct
		SelfFB.ActiveState = "Correct"

		'Add an observation to the accuracy stats
		SelfFB.AccStats.AddObservation Response.Acc

		'Add an observation to the response time stats
		' unless the user did not respond and the author
		' does not want us to add the no response RT
		If Len(Response.RESP) > 0 Then
			SelfFB.RTStats.AddObservation Response.RT
			SelfFB.CorrectRTStats.AddObservation Response.RT
		End If
	Else
		'Is it incorrect or no response?
		If Len(Response.RESP) > 0 Then
			'Set the ActiveState to Incorrect
			SelfFB.ActiveState = "Incorrect"

			'Set the accuracy stats
			SelfFB.AccStats.AddObservation Response.Acc

			'Set the RT stats
			SelfFB.RTStats.AddObservation Response.RT
			SelfFB.IncorrectRTStats.AddObservation Response.RT
		Else
			'Set the ActiveState to NoResponse
			SelfFB.ActiveState = "NoResponse"

			'Does the author want to consider a NoResponse
			' to sum as an incorrect response in the ACC stats?
			If SelfFB.CollectNoRespACCStats = True Then
				SelfFB.AccStats.AddObservation Response.Acc
			End If
		End If
	End If


	Select Case SelfFB.ActiveState
		Case ebUCase_C & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t


			'Text1
			Set SelfFB_SlideText = CSlideText(SelfFB.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			SelfFB_SlideText.Text = "You " &_
				c.GetAttrib("GambleOutcome") &_
				" " &_
				c.GetAttrib("GambleAmount")
			Set SelfFB_SlideText = Nothing

		Case ebUCase_I & ebLCase_n & ebLCase_c & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t


			'Text1
			Set SelfFB_SlideText = CSlideText(SelfFB.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			SelfFB_SlideText.Text = "You will receive the certain option of " &_
				c.GetAttrib("Certain")
			Set SelfFB_SlideText = Nothing

	End Select



	SelfFB.Run


	c.SetAttrib SelfFB.Name & ebDot & ebLogNameOnsetDelay, SelfFB.OnsetDelay
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameOnsetTime, SelfFB.OnsetTime
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameDurationError, SelfFB.DurationError
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameRTTime, SelfFB.RTTime
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameACC, SelfFB.ACC
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameRT, SelfFB.RT
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameRESP, SelfFB.RESP
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameCRESP, SelfFB.CRESP
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameOnsetToOnsetTime, SelfFB.OnsetToOnsetTime


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Feedback_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Feedback_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Feedback_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff1 BEGIN <PulseOff1>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff1 END
	'''''''''''''''''''''''''''''''''''''''''''''


	ITI.Duration = CLng(c.GetAttrib(ebUCase_I & ebUCase_T & ebUCase_I & ebLCase_l & ebLCase_e & ebLCase_n & ebLCase_g & ebLCase_t & ebLCase_h))
	ITI.Run
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetDelay, ITI.OnsetDelay
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetTime, ITI.OnsetTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameDurationError, ITI.DurationError
	c.SetAttrib ITI.Name & ebDot & ebLogNameRTTime, ITI.RTTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameACC, ITI.ACC
	c.SetAttrib ITI.Name & ebDot & ebLogNameRT, ITI.RT
	c.SetAttrib ITI.Name & ebDot & ebLogNameRESP, ITI.RESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameCRESP, ITI.CRESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetToOnsetTime, ITI.OnsetToOnsetTime

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	LASelfGain_theCollection.RemoveAll
	For LASelfGain_nObject = 1 To LASelfGain.ChildObjectCount
		Set LASelfGain_theInputObject = CRteRunnableInputObject(Rte.GetObject(LASelfGain.GetChildObjectName(LASelfGain_nObject)))
		If Not LASelfGain_theInputObject Is Nothing Then LASelfGain_theCollection.Add LASelfGain_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		LASelfGain_bCanExit = True
		For LASelfGain_nObject = 1 To LASelfGain_theCollection.Count
			Set LASelfGain_theInputObject = CRteRunnableInputObject(LASelfGain_theCollection(LASelfGain_nObject))
			If Not LASelfGain_theInputObject Is Nothing Then
				If LASelfGain_theInputObject.InputMasks.IsPending() Then
					LASelfGain_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If LASelfGain_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	LASelfGain_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Options.EndOfProcedure

	Response.EndOfProcedure

	ISI.EndOfProcedure

	SelfFB.EndOfProcedure

	ITI.EndOfProcedure

	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetDelay, Options.OnsetDelay
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetTime, Options.OnsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameDurationError, Options.DurationError
	c.SetAttrib Options.Name & ebDot & ebLogNameDuration, Options.Duration
	c.SetAttrib Options.Name & ebDot & ebLogNameOffsetTime, Options.OffsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameRTTime, Options.RTTime
	c.SetAttrib Options.Name & ebDot & ebLogNameACC, Options.ACC
	c.SetAttrib Options.Name & ebDot & ebLogNameRT, Options.RT
	c.SetAttrib Options.Name & ebDot & ebLogNameRESP, Options.RESP
	c.SetAttrib Options.Name & ebDot & ebLogNameCRESP, Options.CRESP
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetToOnsetTime, Options.OnsetToOnsetTime

	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetDelay, Response.OnsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetTime, Response.OnsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameDurationError, Response.DurationError
	c.SetAttrib Response.Name & ebDot & ebLogNameDuration, Response.Duration
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetTime, Response.OffsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetDelay, Response.OffsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameRTTime, Response.RTTime
	c.SetAttrib Response.Name & ebDot & ebLogNameACC, Response.ACC
	c.SetAttrib Response.Name & ebDot & ebLogNameRT, Response.RT
	c.SetAttrib Response.Name & ebDot & ebLogNameRESP, Response.RESP
	c.SetAttrib Response.Name & ebDot & ebLogNameCRESP, Response.CRESP
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetToOnsetTime, Response.OnsetToOnsetTime

	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetDelay, ISI.OnsetDelay
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetTime, ISI.OnsetTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameDurationError, ISI.DurationError
	c.SetAttrib ISI.Name & ebDot & ebLogNameRTTime, ISI.RTTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameACC, ISI.ACC
	c.SetAttrib ISI.Name & ebDot & ebLogNameRT, ISI.RT
	c.SetAttrib ISI.Name & ebDot & ebLogNameRESP, ISI.RESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameCRESP, ISI.CRESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetToOnsetTime, ISI.OnsetToOnsetTime

	c.SetAttrib SelfFB.Name & ebDot & ebLogNameOnsetDelay, SelfFB.OnsetDelay
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameOnsetTime, SelfFB.OnsetTime
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameDurationError, SelfFB.DurationError
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameRTTime, SelfFB.RTTime
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameACC, SelfFB.ACC
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameRT, SelfFB.RT
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameRESP, SelfFB.RESP
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameCRESP, SelfFB.CRESP
	c.SetAttrib SelfFB.Name & ebDot & ebLogNameOnsetToOnsetTime, SelfFB.OnsetToOnsetTime

	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetDelay, ITI.OnsetDelay
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetTime, ITI.OnsetTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameDurationError, ITI.DurationError
	c.SetAttrib ITI.Name & ebDot & ebLogNameRTTime, ITI.RTTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameACC, ITI.ACC
	c.SetAttrib ITI.Name & ebDot & ebLogNameRT, ITI.RT
	c.SetAttrib ITI.Name & ebDot & ebLogNameRESP, ITI.RESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameCRESP, ITI.CRESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetToOnsetTime, ITI.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Self1_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		SelfSpaceBar1.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	SelfSpaceBar1.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		SelfSpaceBar1EchoClients.RemoveAll
		SelfSpaceBar1.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_A & ebUCase_N & ebUCase_Y & ebBraceClose, ebEmptyText, CLng(SelfSpaceBar1.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	SelfSpaceBar1.Run
		List4.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Self1_theCollection.RemoveAll
	For Self1_nObject = 1 To Self1.ChildObjectCount
		Set Self1_theInputObject = CRteRunnableInputObject(Rte.GetObject(Self1.GetChildObjectName(Self1_nObject)))
		If Not Self1_theInputObject Is Nothing Then Self1_theCollection.Add Self1_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Self1_bCanExit = True
		For Self1_nObject = 1 To Self1_theCollection.Count
			Set Self1_theInputObject = CRteRunnableInputObject(Self1_theCollection(Self1_nObject))
			If Not Self1_theInputObject Is Nothing Then
				If Self1_theInputObject.InputMasks.IsPending() Then
					Self1_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Self1_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Self1_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	SelfSpaceBar1.EndOfProcedure


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Self2_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		SelfSpaceBar2.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	SelfSpaceBar2.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		SelfSpaceBar2EchoClients.RemoveAll
		SelfSpaceBar2.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, ebEmptyText, CLng(SelfSpaceBar2.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	SelfSpaceBar2.Run
		List5.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Self2_theCollection.RemoveAll
	For Self2_nObject = 1 To Self2.ChildObjectCount
		Set Self2_theInputObject = CRteRunnableInputObject(Rte.GetObject(Self2.GetChildObjectName(Self2_nObject)))
		If Not Self2_theInputObject Is Nothing Then Self2_theCollection.Add Self2_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Self2_bCanExit = True
		For Self2_nObject = 1 To Self2_theCollection.Count
			Set Self2_theInputObject = CRteRunnableInputObject(Self2_theCollection(Self2_nObject))
			If Not Self2_theInputObject Is Nothing Then
				If Self2_theInputObject.InputMasks.IsPending() Then
					Self2_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Self2_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Self2_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	SelfSpaceBar2.EndOfProcedure


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Self3_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		SelfSpaceBar3.ResetLoggingProperties
		pleasenotify.ResetLoggingProperties



	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	SelfSpaceBar3.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		SelfSpaceBar3EchoClients.RemoveAll
		SelfSpaceBar3.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, ebEmptyText, CLng(SelfSpaceBar3.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	SelfSpaceBar3.Run
		List6.Run c


	pleasenotify.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		pleasenotifyEchoClients.RemoveAll
		pleasenotify.InputMasks.Add Keyboard.CreateInputMask(ebLCase_z, ebEmptyText, CLng(pleasenotify.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	pleasenotify.Run
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Self3_theCollection.RemoveAll
	For Self3_nObject = 1 To Self3.ChildObjectCount
		Set Self3_theInputObject = CRteRunnableInputObject(Rte.GetObject(Self3.GetChildObjectName(Self3_nObject)))
		If Not Self3_theInputObject Is Nothing Then Self3_theCollection.Add Self3_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Self3_bCanExit = True
		For Self3_nObject = 1 To Self3_theCollection.Count
			Set Self3_theInputObject = CRteRunnableInputObject(Self3_theCollection(Self3_nObject))
			If Not Self3_theInputObject Is Nothing Then
				If Self3_theInputObject.InputMasks.IsPending() Then
					Self3_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Self3_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Self3_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	SelfSpaceBar3.EndOfProcedure

	pleasenotify.EndOfProcedure


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Other1_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		OtherSpaceBar1.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	OtherSpaceBar1.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		OtherSpaceBar1EchoClients.RemoveAll
		OtherSpaceBar1.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, ebEmptyText, CLng(OtherSpaceBar1.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	OtherSpaceBar1.Run
		List7.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Other1_theCollection.RemoveAll
	For Other1_nObject = 1 To Other1.ChildObjectCount
		Set Other1_theInputObject = CRteRunnableInputObject(Rte.GetObject(Other1.GetChildObjectName(Other1_nObject)))
		If Not Other1_theInputObject Is Nothing Then Other1_theCollection.Add Other1_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Other1_bCanExit = True
		For Other1_nObject = 1 To Other1_theCollection.Count
			Set Other1_theInputObject = CRteRunnableInputObject(Other1_theCollection(Other1_nObject))
			If Not Other1_theInputObject Is Nothing Then
				If Other1_theInputObject.InputMasks.IsPending() Then
					Other1_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Other1_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Other1_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	OtherSpaceBar1.EndOfProcedure


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Other2_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		OtherSpaceBar2.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	OtherSpaceBar2.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		OtherSpaceBar2EchoClients.RemoveAll
		OtherSpaceBar2.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, ebEmptyText, CLng(OtherSpaceBar2.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	OtherSpaceBar2.Run
		List8.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Other2_theCollection.RemoveAll
	For Other2_nObject = 1 To Other2.ChildObjectCount
		Set Other2_theInputObject = CRteRunnableInputObject(Rte.GetObject(Other2.GetChildObjectName(Other2_nObject)))
		If Not Other2_theInputObject Is Nothing Then Other2_theCollection.Add Other2_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Other2_bCanExit = True
		For Other2_nObject = 1 To Other2_theCollection.Count
			Set Other2_theInputObject = CRteRunnableInputObject(Other2_theCollection(Other2_nObject))
			If Not Other2_theInputObject Is Nothing Then
				If Other2_theInputObject.InputMasks.IsPending() Then
					Other2_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Other2_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Other2_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	OtherSpaceBar2.EndOfProcedure


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Other3_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		OtherSpaceBar3.ResetLoggingProperties
		pleasenotify.ResetLoggingProperties



	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	OtherSpaceBar3.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		OtherSpaceBar3EchoClients.RemoveAll
		OtherSpaceBar3.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, ebEmptyText, CLng(OtherSpaceBar3.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	OtherSpaceBar3.Run
		List9.Run c


	pleasenotify.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		pleasenotifyEchoClients.RemoveAll
		pleasenotify.InputMasks.Add Keyboard.CreateInputMask(ebLCase_z, ebEmptyText, CLng(pleasenotify.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	pleasenotify.Run
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Other3_theCollection.RemoveAll
	For Other3_nObject = 1 To Other3.ChildObjectCount
		Set Other3_theInputObject = CRteRunnableInputObject(Rte.GetObject(Other3.GetChildObjectName(Other3_nObject)))
		If Not Other3_theInputObject Is Nothing Then Other3_theCollection.Add Other3_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Other3_bCanExit = True
		For Other3_nObject = 1 To Other3_theCollection.Count
			Set Other3_theInputObject = CRteRunnableInputObject(Other3_theCollection(Other3_nObject))
			If Not Other3_theInputObject Is Nothing Then
				If Other3_theInputObject.InputMasks.IsPending() Then
					Other3_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Other3_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Other3_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	OtherSpaceBar3.EndOfProcedure

	pleasenotify.EndOfProcedure


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Both1_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		BothSpaceBar1.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	BothSpaceBar1.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		BothSpaceBar1EchoClients.RemoveAll
		BothSpaceBar1.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, ebEmptyText, CLng(BothSpaceBar1.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	BothSpaceBar1.Run
		List11.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Both1_theCollection.RemoveAll
	For Both1_nObject = 1 To Both1.ChildObjectCount
		Set Both1_theInputObject = CRteRunnableInputObject(Rte.GetObject(Both1.GetChildObjectName(Both1_nObject)))
		If Not Both1_theInputObject Is Nothing Then Both1_theCollection.Add Both1_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Both1_bCanExit = True
		For Both1_nObject = 1 To Both1_theCollection.Count
			Set Both1_theInputObject = CRteRunnableInputObject(Both1_theCollection(Both1_nObject))
			If Not Both1_theInputObject Is Nothing Then
				If Both1_theInputObject.InputMasks.IsPending() Then
					Both1_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Both1_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Both1_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	BothSpaceBar1.EndOfProcedure


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Both2_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		BothSpaceBar2.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	BothSpaceBar2.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		BothSpaceBar2EchoClients.RemoveAll
		BothSpaceBar2.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, ebEmptyText, CLng(BothSpaceBar2.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	BothSpaceBar2.Run
		List12.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Both2_theCollection.RemoveAll
	For Both2_nObject = 1 To Both2.ChildObjectCount
		Set Both2_theInputObject = CRteRunnableInputObject(Rte.GetObject(Both2.GetChildObjectName(Both2_nObject)))
		If Not Both2_theInputObject Is Nothing Then Both2_theCollection.Add Both2_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Both2_bCanExit = True
		For Both2_nObject = 1 To Both2_theCollection.Count
			Set Both2_theInputObject = CRteRunnableInputObject(Both2_theCollection(Both2_nObject))
			If Not Both2_theInputObject Is Nothing Then
				If Both2_theInputObject.InputMasks.IsPending() Then
					Both2_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Both2_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Both2_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	BothSpaceBar2.EndOfProcedure


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Both3_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		BothSpaceBar3.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	BothSpaceBar3.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		BothSpaceBar3EchoClients.RemoveAll
		BothSpaceBar3.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, ebEmptyText, CLng(BothSpaceBar3.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	BothSpaceBar3.Run
		List13.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Both3_theCollection.RemoveAll
	For Both3_nObject = 1 To Both3.ChildObjectCount
		Set Both3_theInputObject = CRteRunnableInputObject(Rte.GetObject(Both3.GetChildObjectName(Both3_nObject)))
		If Not Both3_theInputObject Is Nothing Then Both3_theCollection.Add Both3_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Both3_bCanExit = True
		For Both3_nObject = 1 To Both3_theCollection.Count
			Set Both3_theInputObject = CRteRunnableInputObject(Both3_theCollection(Both3_nObject))
			If Not Both3_theInputObject Is Nothing Then
				If Both3_theInputObject.InputMasks.IsPending() Then
					Both3_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Both3_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Both3_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	BothSpaceBar3.EndOfProcedure


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub LAOtherMixed_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Options.ResetLoggingProperties
		Response.ResetLoggingProperties
		ISI.ResetLoggingProperties
		ITI.ResetLoggingProperties
		Select Case Options.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t


			'Text4
			Set Options_SlideText = CSlideText(Options.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_4))
			Options_SlideText.Text = c.GetAttrib(ebUCase_C & ebLCase_e & ebLCase_r & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n)
			Set Options_SlideText = Nothing

			'Text2
			Set Options_SlideText = CSlideText(Options.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_2))
			Options_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_2)
			Set Options_SlideText = Nothing

			'Text1
			Set Options_SlideText = CSlideText(Options.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			Options_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_1)
			Set Options_SlideText = Nothing

	End Select

		Select Case Response.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t


			'Text3
			Set Response_SlideText = CSlideText(Response.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_3))
			Response_SlideText.Text = c.GetAttrib(ebUCase_C & ebLCase_e & ebLCase_r & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n)
			Set Response_SlideText = Nothing

			'Text2
			Set Response_SlideText = CSlideText(Response.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_2))
			Response_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_2)
			Set Response_SlideText = Nothing

			'Text1
			Set Response_SlideText = CSlideText(Response.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			Response_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_1)
			Set Response_SlideText = Nothing

	End Select




	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn BEGIN <PulseOn>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn END
	'''''''''''''''''''''''''''''''''''''''''''''


	Options.Run

	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetDelay, Options.OnsetDelay
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetTime, Options.OnsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameDurationError, Options.DurationError
	c.SetAttrib Options.Name & ebDot & ebLogNameDuration, Options.Duration
	c.SetAttrib Options.Name & ebDot & ebLogNameOffsetTime, Options.OffsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameRTTime, Options.RTTime
	c.SetAttrib Options.Name & ebDot & ebLogNameACC, Options.ACC
	c.SetAttrib Options.Name & ebDot & ebLogNameRT, Options.RT
	c.SetAttrib Options.Name & ebDot & ebLogNameRESP, Options.RESP
	c.SetAttrib Options.Name & ebDot & ebLogNameCRESP, Options.CRESP
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetToOnsetTime, Options.OnsetToOnsetTime



	Response.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		ResponseEchoClients.RemoveAll
		Response.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1 & ebDigit_2, ebDigit_1, CLng(Response.Duration), CLng(ebDigit_1), ebEndResponseActionNone, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	Response.Run

	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetDelay, Response.OnsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetTime, Response.OnsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameDurationError, Response.DurationError
	c.SetAttrib Response.Name & ebDot & ebLogNameDuration, Response.Duration
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetTime, Response.OffsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetDelay, Response.OffsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameRTTime, Response.RTTime
	c.SetAttrib Response.Name & ebDot & ebLogNameACC, Response.ACC
	c.SetAttrib Response.Name & ebDot & ebLogNameRT, Response.RT
	c.SetAttrib Response.Name & ebDot & ebLogNameRESP, Response.RESP
	c.SetAttrib Response.Name & ebDot & ebLogNameCRESP, Response.CRESP
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetToOnsetTime, Response.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff BEGIN <PulseOff>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff END
	'''''''''''''''''''''''''''''''''''''''''''''


	ISI.Run
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetDelay, ISI.OnsetDelay
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetTime, ISI.OnsetTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameDurationError, ISI.DurationError
	c.SetAttrib ISI.Name & ebDot & ebLogNameRTTime, ISI.RTTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameACC, ISI.ACC
	c.SetAttrib ISI.Name & ebDot & ebLogNameRT, ISI.RT
	c.SetAttrib ISI.Name & ebDot & ebLogNameRESP, ISI.RESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameCRESP, ISI.CRESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetToOnsetTime, ISI.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn1 BEGIN <PulseOn1>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn1 END
	'''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Feedback_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Feedback_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Feedback_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing the input object pending any input masks.
	' To prevent this code from being generated, set the Feedback object's
	'.ProcessInputObjectPendingInputMasks property to No/False.
	'
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		'Input Masks still pending?
		If Not Response.InputMasks.IsPending() Then
			Exit Do
		End If

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop
	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	'Determine if there are any InputMasks with a ebTimeLimitUntilFeedback set
	For OtherFB_ChildIterator = 1 To LAOtherMixed.ChildObjectCount
		Set OtherFB_Child = CRteRunnableInputObject(Rte.GetObject(LAOtherMixed.GetChildObjectName(OtherFB_ChildIterator)))
		If Not OtherFB_Child Is Nothing Then

			'Have we reached this FeedbackDisplay?
			'(we do not terminate InputMask with ebTimeLimitUntilFeedback
			'  that occur after our FeedbackDisplay)
			If OtherFB_Child.Name = OtherFB.Name Then Exit For

			'Enumerate through each object and then through each InputMask
			'terminate any input masks that have ebTimeLimitUntilFeeback set
			For OtherFB_MaskIterator = 1 To OtherFB_Child.InputMasks.Count
				Set OtherFB_Mask = OtherFB_Child.InputMasks(OtherFB_MaskIterator)
				If Not OtherFB_Mask Is Nothing Then
					If OtherFB_Mask.Status = ebStatusArmed Then
						If OtherFB_Mask.TimeLimit = ebTimeLimitUntilFeedback Then
							OtherFB_Mask.Terminate
						End If
					End If
				End If
			Next
		End If
	Next

	If Response.ACC = 1 Then
		'Set the ActiveState to Correct
		OtherFB.ActiveState = "Correct"

		'Add an observation to the accuracy stats
		OtherFB.AccStats.AddObservation Response.Acc

		'Add an observation to the response time stats
		' unless the user did not respond and the author
		' does not want us to add the no response RT
		If Len(Response.RESP) > 0 Then
			OtherFB.RTStats.AddObservation Response.RT
			OtherFB.CorrectRTStats.AddObservation Response.RT
		End If
	Else
		'Is it incorrect or no response?
		If Len(Response.RESP) > 0 Then
			'Set the ActiveState to Incorrect
			OtherFB.ActiveState = "Incorrect"

			'Set the accuracy stats
			OtherFB.AccStats.AddObservation Response.Acc

			'Set the RT stats
			OtherFB.RTStats.AddObservation Response.RT
			OtherFB.IncorrectRTStats.AddObservation Response.RT
		Else
			'Set the ActiveState to NoResponse
			OtherFB.ActiveState = "NoResponse"

			'Does the author want to consider a NoResponse
			' to sum as an incorrect response in the ACC stats?
			If OtherFB.CollectNoRespACCStats = True Then
				OtherFB.AccStats.AddObservation Response.Acc
			End If
		End If
	End If


	Select Case OtherFB.ActiveState
		Case ebUCase_C & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t


			'Text1
			Set OtherFB_SlideText = CSlideText(OtherFB.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			OtherFB_SlideText.Text = c.GetAttrib("PartnerName") &_
				" " &_
				c.GetAttrib("GambleOutcome") &_
				" " &_
				c.GetAttrib("GambleAmount")
			Set OtherFB_SlideText = Nothing

		Case ebUCase_I & ebLCase_n & ebLCase_c & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t


			'Text1
			Set OtherFB_SlideText = CSlideText(OtherFB.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			OtherFB_SlideText.Text = c.GetAttrib("PartnerName") &_
				" will receive the certain option of " &_
				c.GetAttrib("Certain")
			Set OtherFB_SlideText = Nothing

	End Select



	OtherFB.Run


	c.SetAttrib OtherFB.Name & ebDot & ebLogNameOnsetDelay, OtherFB.OnsetDelay
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameOnsetTime, OtherFB.OnsetTime
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameDurationError, OtherFB.DurationError
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameRTTime, OtherFB.RTTime
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameACC, OtherFB.ACC
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameRT, OtherFB.RT
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameRESP, OtherFB.RESP
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameCRESP, OtherFB.CRESP
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameOnsetToOnsetTime, OtherFB.OnsetToOnsetTime


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Feedback_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Feedback_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Feedback_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff1 BEGIN <PulseOff1>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff1 END
	'''''''''''''''''''''''''''''''''''''''''''''


	ITI.Duration = CLng(c.GetAttrib(ebUCase_I & ebUCase_T & ebUCase_I & ebLCase_l & ebLCase_e & ebLCase_n & ebLCase_g & ebLCase_t & ebLCase_h))
	ITI.Run
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetDelay, ITI.OnsetDelay
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetTime, ITI.OnsetTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameDurationError, ITI.DurationError
	c.SetAttrib ITI.Name & ebDot & ebLogNameRTTime, ITI.RTTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameACC, ITI.ACC
	c.SetAttrib ITI.Name & ebDot & ebLogNameRT, ITI.RT
	c.SetAttrib ITI.Name & ebDot & ebLogNameRESP, ITI.RESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameCRESP, ITI.CRESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetToOnsetTime, ITI.OnsetToOnsetTime

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	LAOtherMixed_theCollection.RemoveAll
	For LAOtherMixed_nObject = 1 To LAOtherMixed.ChildObjectCount
		Set LAOtherMixed_theInputObject = CRteRunnableInputObject(Rte.GetObject(LAOtherMixed.GetChildObjectName(LAOtherMixed_nObject)))
		If Not LAOtherMixed_theInputObject Is Nothing Then LAOtherMixed_theCollection.Add LAOtherMixed_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		LAOtherMixed_bCanExit = True
		For LAOtherMixed_nObject = 1 To LAOtherMixed_theCollection.Count
			Set LAOtherMixed_theInputObject = CRteRunnableInputObject(LAOtherMixed_theCollection(LAOtherMixed_nObject))
			If Not LAOtherMixed_theInputObject Is Nothing Then
				If LAOtherMixed_theInputObject.InputMasks.IsPending() Then
					LAOtherMixed_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If LAOtherMixed_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	LAOtherMixed_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Options.EndOfProcedure

	Response.EndOfProcedure

	ISI.EndOfProcedure

	OtherFB.EndOfProcedure

	ITI.EndOfProcedure

	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetDelay, Options.OnsetDelay
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetTime, Options.OnsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameDurationError, Options.DurationError
	c.SetAttrib Options.Name & ebDot & ebLogNameDuration, Options.Duration
	c.SetAttrib Options.Name & ebDot & ebLogNameOffsetTime, Options.OffsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameRTTime, Options.RTTime
	c.SetAttrib Options.Name & ebDot & ebLogNameACC, Options.ACC
	c.SetAttrib Options.Name & ebDot & ebLogNameRT, Options.RT
	c.SetAttrib Options.Name & ebDot & ebLogNameRESP, Options.RESP
	c.SetAttrib Options.Name & ebDot & ebLogNameCRESP, Options.CRESP
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetToOnsetTime, Options.OnsetToOnsetTime

	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetDelay, Response.OnsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetTime, Response.OnsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameDurationError, Response.DurationError
	c.SetAttrib Response.Name & ebDot & ebLogNameDuration, Response.Duration
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetTime, Response.OffsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetDelay, Response.OffsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameRTTime, Response.RTTime
	c.SetAttrib Response.Name & ebDot & ebLogNameACC, Response.ACC
	c.SetAttrib Response.Name & ebDot & ebLogNameRT, Response.RT
	c.SetAttrib Response.Name & ebDot & ebLogNameRESP, Response.RESP
	c.SetAttrib Response.Name & ebDot & ebLogNameCRESP, Response.CRESP
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetToOnsetTime, Response.OnsetToOnsetTime

	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetDelay, ISI.OnsetDelay
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetTime, ISI.OnsetTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameDurationError, ISI.DurationError
	c.SetAttrib ISI.Name & ebDot & ebLogNameRTTime, ISI.RTTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameACC, ISI.ACC
	c.SetAttrib ISI.Name & ebDot & ebLogNameRT, ISI.RT
	c.SetAttrib ISI.Name & ebDot & ebLogNameRESP, ISI.RESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameCRESP, ISI.CRESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetToOnsetTime, ISI.OnsetToOnsetTime

	c.SetAttrib OtherFB.Name & ebDot & ebLogNameOnsetDelay, OtherFB.OnsetDelay
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameOnsetTime, OtherFB.OnsetTime
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameDurationError, OtherFB.DurationError
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameRTTime, OtherFB.RTTime
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameACC, OtherFB.ACC
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameRT, OtherFB.RT
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameRESP, OtherFB.RESP
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameCRESP, OtherFB.CRESP
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameOnsetToOnsetTime, OtherFB.OnsetToOnsetTime

	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetDelay, ITI.OnsetDelay
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetTime, ITI.OnsetTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameDurationError, ITI.DurationError
	c.SetAttrib ITI.Name & ebDot & ebLogNameRTTime, ITI.RTTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameACC, ITI.ACC
	c.SetAttrib ITI.Name & ebDot & ebLogNameRT, ITI.RT
	c.SetAttrib ITI.Name & ebDot & ebLogNameRESP, ITI.RESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameCRESP, ITI.CRESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetToOnsetTime, ITI.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub LAOtherGain_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Options.ResetLoggingProperties
		Response.ResetLoggingProperties
		ISI.ResetLoggingProperties
		ITI.ResetLoggingProperties
		Select Case Options.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t


			'Text4
			Set Options_SlideText = CSlideText(Options.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_4))
			Options_SlideText.Text = c.GetAttrib(ebUCase_C & ebLCase_e & ebLCase_r & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n)
			Set Options_SlideText = Nothing

			'Text2
			Set Options_SlideText = CSlideText(Options.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_2))
			Options_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_2)
			Set Options_SlideText = Nothing

			'Text1
			Set Options_SlideText = CSlideText(Options.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			Options_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_1)
			Set Options_SlideText = Nothing

	End Select

		Select Case Response.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t


			'Text3
			Set Response_SlideText = CSlideText(Response.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_3))
			Response_SlideText.Text = c.GetAttrib(ebUCase_C & ebLCase_e & ebLCase_r & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n)
			Set Response_SlideText = Nothing

			'Text2
			Set Response_SlideText = CSlideText(Response.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_2))
			Response_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_2)
			Set Response_SlideText = Nothing

			'Text1
			Set Response_SlideText = CSlideText(Response.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			Response_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_1)
			Set Response_SlideText = Nothing

	End Select




	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn BEGIN <PulseOn>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn END
	'''''''''''''''''''''''''''''''''''''''''''''


	Options.Run

	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetDelay, Options.OnsetDelay
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetTime, Options.OnsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameDurationError, Options.DurationError
	c.SetAttrib Options.Name & ebDot & ebLogNameDuration, Options.Duration
	c.SetAttrib Options.Name & ebDot & ebLogNameOffsetTime, Options.OffsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameRTTime, Options.RTTime
	c.SetAttrib Options.Name & ebDot & ebLogNameACC, Options.ACC
	c.SetAttrib Options.Name & ebDot & ebLogNameRT, Options.RT
	c.SetAttrib Options.Name & ebDot & ebLogNameRESP, Options.RESP
	c.SetAttrib Options.Name & ebDot & ebLogNameCRESP, Options.CRESP
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetToOnsetTime, Options.OnsetToOnsetTime



	Response.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		ResponseEchoClients.RemoveAll
		Response.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1 & ebDigit_2, ebDigit_1, CLng(Response.Duration), CLng(ebDigit_1), ebEndResponseActionNone, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	Response.Run

	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetDelay, Response.OnsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetTime, Response.OnsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameDurationError, Response.DurationError
	c.SetAttrib Response.Name & ebDot & ebLogNameDuration, Response.Duration
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetTime, Response.OffsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetDelay, Response.OffsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameRTTime, Response.RTTime
	c.SetAttrib Response.Name & ebDot & ebLogNameACC, Response.ACC
	c.SetAttrib Response.Name & ebDot & ebLogNameRT, Response.RT
	c.SetAttrib Response.Name & ebDot & ebLogNameRESP, Response.RESP
	c.SetAttrib Response.Name & ebDot & ebLogNameCRESP, Response.CRESP
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetToOnsetTime, Response.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff BEGIN <PulseOff>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff END
	'''''''''''''''''''''''''''''''''''''''''''''


	ISI.Run
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetDelay, ISI.OnsetDelay
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetTime, ISI.OnsetTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameDurationError, ISI.DurationError
	c.SetAttrib ISI.Name & ebDot & ebLogNameRTTime, ISI.RTTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameACC, ISI.ACC
	c.SetAttrib ISI.Name & ebDot & ebLogNameRT, ISI.RT
	c.SetAttrib ISI.Name & ebDot & ebLogNameRESP, ISI.RESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameCRESP, ISI.CRESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetToOnsetTime, ISI.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn1 BEGIN <PulseOn1>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn1 END
	'''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Feedback_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Feedback_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Feedback_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing the input object pending any input masks.
	' To prevent this code from being generated, set the Feedback object's
	'.ProcessInputObjectPendingInputMasks property to No/False.
	'
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		'Input Masks still pending?
		If Not Response.InputMasks.IsPending() Then
			Exit Do
		End If

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop
	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	'Determine if there are any InputMasks with a ebTimeLimitUntilFeedback set
	For OtherFB_ChildIterator = 1 To LAOtherGain.ChildObjectCount
		Set OtherFB_Child = CRteRunnableInputObject(Rte.GetObject(LAOtherGain.GetChildObjectName(OtherFB_ChildIterator)))
		If Not OtherFB_Child Is Nothing Then

			'Have we reached this FeedbackDisplay?
			'(we do not terminate InputMask with ebTimeLimitUntilFeedback
			'  that occur after our FeedbackDisplay)
			If OtherFB_Child.Name = OtherFB.Name Then Exit For

			'Enumerate through each object and then through each InputMask
			'terminate any input masks that have ebTimeLimitUntilFeeback set
			For OtherFB_MaskIterator = 1 To OtherFB_Child.InputMasks.Count
				Set OtherFB_Mask = OtherFB_Child.InputMasks(OtherFB_MaskIterator)
				If Not OtherFB_Mask Is Nothing Then
					If OtherFB_Mask.Status = ebStatusArmed Then
						If OtherFB_Mask.TimeLimit = ebTimeLimitUntilFeedback Then
							OtherFB_Mask.Terminate
						End If
					End If
				End If
			Next
		End If
	Next

	If Response.ACC = 1 Then
		'Set the ActiveState to Correct
		OtherFB.ActiveState = "Correct"

		'Add an observation to the accuracy stats
		OtherFB.AccStats.AddObservation Response.Acc

		'Add an observation to the response time stats
		' unless the user did not respond and the author
		' does not want us to add the no response RT
		If Len(Response.RESP) > 0 Then
			OtherFB.RTStats.AddObservation Response.RT
			OtherFB.CorrectRTStats.AddObservation Response.RT
		End If
	Else
		'Is it incorrect or no response?
		If Len(Response.RESP) > 0 Then
			'Set the ActiveState to Incorrect
			OtherFB.ActiveState = "Incorrect"

			'Set the accuracy stats
			OtherFB.AccStats.AddObservation Response.Acc

			'Set the RT stats
			OtherFB.RTStats.AddObservation Response.RT
			OtherFB.IncorrectRTStats.AddObservation Response.RT
		Else
			'Set the ActiveState to NoResponse
			OtherFB.ActiveState = "NoResponse"

			'Does the author want to consider a NoResponse
			' to sum as an incorrect response in the ACC stats?
			If OtherFB.CollectNoRespACCStats = True Then
				OtherFB.AccStats.AddObservation Response.Acc
			End If
		End If
	End If


	Select Case OtherFB.ActiveState
		Case ebUCase_C & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t


			'Text1
			Set OtherFB_SlideText = CSlideText(OtherFB.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			OtherFB_SlideText.Text = c.GetAttrib("PartnerName") &_
				" " &_
				c.GetAttrib("GambleOutcome") &_
				" " &_
				c.GetAttrib("GambleAmount")
			Set OtherFB_SlideText = Nothing

		Case ebUCase_I & ebLCase_n & ebLCase_c & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t


			'Text1
			Set OtherFB_SlideText = CSlideText(OtherFB.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			OtherFB_SlideText.Text = c.GetAttrib("PartnerName") &_
				" will receive the certain option of " &_
				c.GetAttrib("Certain")
			Set OtherFB_SlideText = Nothing

	End Select



	OtherFB.Run


	c.SetAttrib OtherFB.Name & ebDot & ebLogNameOnsetDelay, OtherFB.OnsetDelay
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameOnsetTime, OtherFB.OnsetTime
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameDurationError, OtherFB.DurationError
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameRTTime, OtherFB.RTTime
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameACC, OtherFB.ACC
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameRT, OtherFB.RT
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameRESP, OtherFB.RESP
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameCRESP, OtherFB.CRESP
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameOnsetToOnsetTime, OtherFB.OnsetToOnsetTime


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Feedback_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Feedback_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Feedback_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff1 BEGIN <PulseOff1>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff1 END
	'''''''''''''''''''''''''''''''''''''''''''''


	ITI.Duration = CLng(c.GetAttrib(ebUCase_I & ebUCase_T & ebUCase_I & ebLCase_l & ebLCase_e & ebLCase_n & ebLCase_g & ebLCase_t & ebLCase_h))
	ITI.Run
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetDelay, ITI.OnsetDelay
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetTime, ITI.OnsetTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameDurationError, ITI.DurationError
	c.SetAttrib ITI.Name & ebDot & ebLogNameRTTime, ITI.RTTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameACC, ITI.ACC
	c.SetAttrib ITI.Name & ebDot & ebLogNameRT, ITI.RT
	c.SetAttrib ITI.Name & ebDot & ebLogNameRESP, ITI.RESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameCRESP, ITI.CRESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetToOnsetTime, ITI.OnsetToOnsetTime

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	LAOtherGain_theCollection.RemoveAll
	For LAOtherGain_nObject = 1 To LAOtherGain.ChildObjectCount
		Set LAOtherGain_theInputObject = CRteRunnableInputObject(Rte.GetObject(LAOtherGain.GetChildObjectName(LAOtherGain_nObject)))
		If Not LAOtherGain_theInputObject Is Nothing Then LAOtherGain_theCollection.Add LAOtherGain_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		LAOtherGain_bCanExit = True
		For LAOtherGain_nObject = 1 To LAOtherGain_theCollection.Count
			Set LAOtherGain_theInputObject = CRteRunnableInputObject(LAOtherGain_theCollection(LAOtherGain_nObject))
			If Not LAOtherGain_theInputObject Is Nothing Then
				If LAOtherGain_theInputObject.InputMasks.IsPending() Then
					LAOtherGain_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If LAOtherGain_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	LAOtherGain_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Options.EndOfProcedure

	Response.EndOfProcedure

	ISI.EndOfProcedure

	OtherFB.EndOfProcedure

	ITI.EndOfProcedure

	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetDelay, Options.OnsetDelay
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetTime, Options.OnsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameDurationError, Options.DurationError
	c.SetAttrib Options.Name & ebDot & ebLogNameDuration, Options.Duration
	c.SetAttrib Options.Name & ebDot & ebLogNameOffsetTime, Options.OffsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameRTTime, Options.RTTime
	c.SetAttrib Options.Name & ebDot & ebLogNameACC, Options.ACC
	c.SetAttrib Options.Name & ebDot & ebLogNameRT, Options.RT
	c.SetAttrib Options.Name & ebDot & ebLogNameRESP, Options.RESP
	c.SetAttrib Options.Name & ebDot & ebLogNameCRESP, Options.CRESP
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetToOnsetTime, Options.OnsetToOnsetTime

	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetDelay, Response.OnsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetTime, Response.OnsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameDurationError, Response.DurationError
	c.SetAttrib Response.Name & ebDot & ebLogNameDuration, Response.Duration
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetTime, Response.OffsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetDelay, Response.OffsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameRTTime, Response.RTTime
	c.SetAttrib Response.Name & ebDot & ebLogNameACC, Response.ACC
	c.SetAttrib Response.Name & ebDot & ebLogNameRT, Response.RT
	c.SetAttrib Response.Name & ebDot & ebLogNameRESP, Response.RESP
	c.SetAttrib Response.Name & ebDot & ebLogNameCRESP, Response.CRESP
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetToOnsetTime, Response.OnsetToOnsetTime

	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetDelay, ISI.OnsetDelay
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetTime, ISI.OnsetTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameDurationError, ISI.DurationError
	c.SetAttrib ISI.Name & ebDot & ebLogNameRTTime, ISI.RTTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameACC, ISI.ACC
	c.SetAttrib ISI.Name & ebDot & ebLogNameRT, ISI.RT
	c.SetAttrib ISI.Name & ebDot & ebLogNameRESP, ISI.RESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameCRESP, ISI.CRESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetToOnsetTime, ISI.OnsetToOnsetTime

	c.SetAttrib OtherFB.Name & ebDot & ebLogNameOnsetDelay, OtherFB.OnsetDelay
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameOnsetTime, OtherFB.OnsetTime
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameDurationError, OtherFB.DurationError
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameRTTime, OtherFB.RTTime
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameACC, OtherFB.ACC
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameRT, OtherFB.RT
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameRESP, OtherFB.RESP
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameCRESP, OtherFB.CRESP
	c.SetAttrib OtherFB.Name & ebDot & ebLogNameOnsetToOnsetTime, OtherFB.OnsetToOnsetTime

	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetDelay, ITI.OnsetDelay
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetTime, ITI.OnsetTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameDurationError, ITI.DurationError
	c.SetAttrib ITI.Name & ebDot & ebLogNameRTTime, ITI.RTTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameACC, ITI.ACC
	c.SetAttrib ITI.Name & ebDot & ebLogNameRT, ITI.RT
	c.SetAttrib ITI.Name & ebDot & ebLogNameRESP, ITI.RESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameCRESP, ITI.CRESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetToOnsetTime, ITI.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub LABothMixed_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Options.ResetLoggingProperties
		Response.ResetLoggingProperties
		ISI.ResetLoggingProperties
		ITI.ResetLoggingProperties
		Select Case Options.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t


			'Text4
			Set Options_SlideText = CSlideText(Options.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_4))
			Options_SlideText.Text = c.GetAttrib(ebUCase_C & ebLCase_e & ebLCase_r & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n)
			Set Options_SlideText = Nothing

			'Text2
			Set Options_SlideText = CSlideText(Options.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_2))
			Options_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_2)
			Set Options_SlideText = Nothing

			'Text1
			Set Options_SlideText = CSlideText(Options.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			Options_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_1)
			Set Options_SlideText = Nothing

	End Select

		Select Case Response.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t


			'Text3
			Set Response_SlideText = CSlideText(Response.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_3))
			Response_SlideText.Text = c.GetAttrib(ebUCase_C & ebLCase_e & ebLCase_r & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n)
			Set Response_SlideText = Nothing

			'Text2
			Set Response_SlideText = CSlideText(Response.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_2))
			Response_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_2)
			Set Response_SlideText = Nothing

			'Text1
			Set Response_SlideText = CSlideText(Response.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			Response_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_1)
			Set Response_SlideText = Nothing

	End Select




	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn BEGIN <PulseOn>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn END
	'''''''''''''''''''''''''''''''''''''''''''''


	Options.Run

	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetDelay, Options.OnsetDelay
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetTime, Options.OnsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameDurationError, Options.DurationError
	c.SetAttrib Options.Name & ebDot & ebLogNameDuration, Options.Duration
	c.SetAttrib Options.Name & ebDot & ebLogNameOffsetTime, Options.OffsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameRTTime, Options.RTTime
	c.SetAttrib Options.Name & ebDot & ebLogNameACC, Options.ACC
	c.SetAttrib Options.Name & ebDot & ebLogNameRT, Options.RT
	c.SetAttrib Options.Name & ebDot & ebLogNameRESP, Options.RESP
	c.SetAttrib Options.Name & ebDot & ebLogNameCRESP, Options.CRESP
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetToOnsetTime, Options.OnsetToOnsetTime



	Response.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		ResponseEchoClients.RemoveAll
		Response.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1 & ebDigit_2, ebDigit_1, CLng(Response.Duration), CLng(ebDigit_1), ebEndResponseActionNone, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	Response.Run

	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetDelay, Response.OnsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetTime, Response.OnsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameDurationError, Response.DurationError
	c.SetAttrib Response.Name & ebDot & ebLogNameDuration, Response.Duration
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetTime, Response.OffsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetDelay, Response.OffsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameRTTime, Response.RTTime
	c.SetAttrib Response.Name & ebDot & ebLogNameACC, Response.ACC
	c.SetAttrib Response.Name & ebDot & ebLogNameRT, Response.RT
	c.SetAttrib Response.Name & ebDot & ebLogNameRESP, Response.RESP
	c.SetAttrib Response.Name & ebDot & ebLogNameCRESP, Response.CRESP
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetToOnsetTime, Response.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff BEGIN <PulseOff>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff END
	'''''''''''''''''''''''''''''''''''''''''''''


	ISI.Run
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetDelay, ISI.OnsetDelay
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetTime, ISI.OnsetTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameDurationError, ISI.DurationError
	c.SetAttrib ISI.Name & ebDot & ebLogNameRTTime, ISI.RTTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameACC, ISI.ACC
	c.SetAttrib ISI.Name & ebDot & ebLogNameRT, ISI.RT
	c.SetAttrib ISI.Name & ebDot & ebLogNameRESP, ISI.RESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameCRESP, ISI.CRESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetToOnsetTime, ISI.OnsetToOnsetTime


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Feedback_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Feedback_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Feedback_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing the input object pending any input masks.
	' To prevent this code from being generated, set the Feedback object's
	'.ProcessInputObjectPendingInputMasks property to No/False.
	'
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		'Input Masks still pending?
		If Not Response.InputMasks.IsPending() Then
			Exit Do
		End If

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop
	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	'Determine if there are any InputMasks with a ebTimeLimitUntilFeedback set
	For BothFB_ChildIterator = 1 To LABothMixed.ChildObjectCount
		Set BothFB_Child = CRteRunnableInputObject(Rte.GetObject(LABothMixed.GetChildObjectName(BothFB_ChildIterator)))
		If Not BothFB_Child Is Nothing Then

			'Have we reached this FeedbackDisplay?
			'(we do not terminate InputMask with ebTimeLimitUntilFeedback
			'  that occur after our FeedbackDisplay)
			If BothFB_Child.Name = BothFB.Name Then Exit For

			'Enumerate through each object and then through each InputMask
			'terminate any input masks that have ebTimeLimitUntilFeeback set
			For BothFB_MaskIterator = 1 To BothFB_Child.InputMasks.Count
				Set BothFB_Mask = BothFB_Child.InputMasks(BothFB_MaskIterator)
				If Not BothFB_Mask Is Nothing Then
					If BothFB_Mask.Status = ebStatusArmed Then
						If BothFB_Mask.TimeLimit = ebTimeLimitUntilFeedback Then
							BothFB_Mask.Terminate
						End If
					End If
				End If
			Next
		End If
	Next

	If Response.ACC = 1 Then
		'Set the ActiveState to Correct
		BothFB.ActiveState = "Correct"

		'Add an observation to the accuracy stats
		BothFB.AccStats.AddObservation Response.Acc

		'Add an observation to the response time stats
		' unless the user did not respond and the author
		' does not want us to add the no response RT
		If Len(Response.RESP) > 0 Then
			BothFB.RTStats.AddObservation Response.RT
			BothFB.CorrectRTStats.AddObservation Response.RT
		End If
	Else
		'Is it incorrect or no response?
		If Len(Response.RESP) > 0 Then
			'Set the ActiveState to Incorrect
			BothFB.ActiveState = "Incorrect"

			'Set the accuracy stats
			BothFB.AccStats.AddObservation Response.Acc

			'Set the RT stats
			BothFB.RTStats.AddObservation Response.RT
			BothFB.IncorrectRTStats.AddObservation Response.RT
		Else
			'Set the ActiveState to NoResponse
			BothFB.ActiveState = "NoResponse"

			'Does the author want to consider a NoResponse
			' to sum as an incorrect response in the ACC stats?
			If BothFB.CollectNoRespACCStats = True Then
				BothFB.AccStats.AddObservation Response.Acc
			End If
		End If
	End If


	Select Case BothFB.ActiveState
		Case ebUCase_C & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t


			'Text1
			Set BothFB_SlideText = CSlideText(BothFB.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			BothFB_SlideText.Text = "You and " &_
				c.GetAttrib("PartnerName") &_
				" " &_
				c.GetAttrib("GambleOutcome") &_
				" " &_
				c.GetAttrib("GambleAmount")
			Set BothFB_SlideText = Nothing

		Case ebUCase_I & ebLCase_n & ebLCase_c & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t


			'Text1
			Set BothFB_SlideText = CSlideText(BothFB.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			BothFB_SlideText.Text = "You and " &_
				c.GetAttrib("PartnerName") &_
				" will receive the certain option of " &_
				c.GetAttrib("Certain")
			Set BothFB_SlideText = Nothing

	End Select



	BothFB.Run


	c.SetAttrib BothFB.Name & ebDot & ebLogNameOnsetDelay, BothFB.OnsetDelay
	c.SetAttrib BothFB.Name & ebDot & ebLogNameOnsetTime, BothFB.OnsetTime
	c.SetAttrib BothFB.Name & ebDot & ebLogNameDurationError, BothFB.DurationError
	c.SetAttrib BothFB.Name & ebDot & ebLogNameRTTime, BothFB.RTTime
	c.SetAttrib BothFB.Name & ebDot & ebLogNameACC, BothFB.ACC
	c.SetAttrib BothFB.Name & ebDot & ebLogNameRT, BothFB.RT
	c.SetAttrib BothFB.Name & ebDot & ebLogNameRESP, BothFB.RESP
	c.SetAttrib BothFB.Name & ebDot & ebLogNameCRESP, BothFB.CRESP
	c.SetAttrib BothFB.Name & ebDot & ebLogNameOnsetToOnsetTime, BothFB.OnsetToOnsetTime


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Feedback_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Feedback_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Feedback_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	ITI.Duration = CLng(c.GetAttrib(ebUCase_I & ebUCase_T & ebUCase_I & ebLCase_l & ebLCase_e & ebLCase_n & ebLCase_g & ebLCase_t & ebLCase_h))
	ITI.Run
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetDelay, ITI.OnsetDelay
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetTime, ITI.OnsetTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameDurationError, ITI.DurationError
	c.SetAttrib ITI.Name & ebDot & ebLogNameRTTime, ITI.RTTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameACC, ITI.ACC
	c.SetAttrib ITI.Name & ebDot & ebLogNameRT, ITI.RT
	c.SetAttrib ITI.Name & ebDot & ebLogNameRESP, ITI.RESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameCRESP, ITI.CRESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetToOnsetTime, ITI.OnsetToOnsetTime

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	LABothMixed_theCollection.RemoveAll
	For LABothMixed_nObject = 1 To LABothMixed.ChildObjectCount
		Set LABothMixed_theInputObject = CRteRunnableInputObject(Rte.GetObject(LABothMixed.GetChildObjectName(LABothMixed_nObject)))
		If Not LABothMixed_theInputObject Is Nothing Then LABothMixed_theCollection.Add LABothMixed_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		LABothMixed_bCanExit = True
		For LABothMixed_nObject = 1 To LABothMixed_theCollection.Count
			Set LABothMixed_theInputObject = CRteRunnableInputObject(LABothMixed_theCollection(LABothMixed_nObject))
			If Not LABothMixed_theInputObject Is Nothing Then
				If LABothMixed_theInputObject.InputMasks.IsPending() Then
					LABothMixed_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If LABothMixed_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	LABothMixed_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Options.EndOfProcedure

	Response.EndOfProcedure

	ISI.EndOfProcedure

	BothFB.EndOfProcedure

	ITI.EndOfProcedure

	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetDelay, Options.OnsetDelay
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetTime, Options.OnsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameDurationError, Options.DurationError
	c.SetAttrib Options.Name & ebDot & ebLogNameDuration, Options.Duration
	c.SetAttrib Options.Name & ebDot & ebLogNameOffsetTime, Options.OffsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameRTTime, Options.RTTime
	c.SetAttrib Options.Name & ebDot & ebLogNameACC, Options.ACC
	c.SetAttrib Options.Name & ebDot & ebLogNameRT, Options.RT
	c.SetAttrib Options.Name & ebDot & ebLogNameRESP, Options.RESP
	c.SetAttrib Options.Name & ebDot & ebLogNameCRESP, Options.CRESP
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetToOnsetTime, Options.OnsetToOnsetTime

	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetDelay, Response.OnsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetTime, Response.OnsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameDurationError, Response.DurationError
	c.SetAttrib Response.Name & ebDot & ebLogNameDuration, Response.Duration
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetTime, Response.OffsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetDelay, Response.OffsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameRTTime, Response.RTTime
	c.SetAttrib Response.Name & ebDot & ebLogNameACC, Response.ACC
	c.SetAttrib Response.Name & ebDot & ebLogNameRT, Response.RT
	c.SetAttrib Response.Name & ebDot & ebLogNameRESP, Response.RESP
	c.SetAttrib Response.Name & ebDot & ebLogNameCRESP, Response.CRESP
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetToOnsetTime, Response.OnsetToOnsetTime

	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetDelay, ISI.OnsetDelay
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetTime, ISI.OnsetTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameDurationError, ISI.DurationError
	c.SetAttrib ISI.Name & ebDot & ebLogNameRTTime, ISI.RTTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameACC, ISI.ACC
	c.SetAttrib ISI.Name & ebDot & ebLogNameRT, ISI.RT
	c.SetAttrib ISI.Name & ebDot & ebLogNameRESP, ISI.RESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameCRESP, ISI.CRESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetToOnsetTime, ISI.OnsetToOnsetTime

	c.SetAttrib BothFB.Name & ebDot & ebLogNameOnsetDelay, BothFB.OnsetDelay
	c.SetAttrib BothFB.Name & ebDot & ebLogNameOnsetTime, BothFB.OnsetTime
	c.SetAttrib BothFB.Name & ebDot & ebLogNameDurationError, BothFB.DurationError
	c.SetAttrib BothFB.Name & ebDot & ebLogNameRTTime, BothFB.RTTime
	c.SetAttrib BothFB.Name & ebDot & ebLogNameACC, BothFB.ACC
	c.SetAttrib BothFB.Name & ebDot & ebLogNameRT, BothFB.RT
	c.SetAttrib BothFB.Name & ebDot & ebLogNameRESP, BothFB.RESP
	c.SetAttrib BothFB.Name & ebDot & ebLogNameCRESP, BothFB.CRESP
	c.SetAttrib BothFB.Name & ebDot & ebLogNameOnsetToOnsetTime, BothFB.OnsetToOnsetTime

	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetDelay, ITI.OnsetDelay
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetTime, ITI.OnsetTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameDurationError, ITI.DurationError
	c.SetAttrib ITI.Name & ebDot & ebLogNameRTTime, ITI.RTTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameACC, ITI.ACC
	c.SetAttrib ITI.Name & ebDot & ebLogNameRT, ITI.RT
	c.SetAttrib ITI.Name & ebDot & ebLogNameRESP, ITI.RESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameCRESP, ITI.CRESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetToOnsetTime, ITI.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub LABothGain_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Options.ResetLoggingProperties
		Response.ResetLoggingProperties
		ISI.ResetLoggingProperties
		ITI.ResetLoggingProperties
		Select Case Options.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t


			'Text4
			Set Options_SlideText = CSlideText(Options.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_4))
			Options_SlideText.Text = c.GetAttrib(ebUCase_C & ebLCase_e & ebLCase_r & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n)
			Set Options_SlideText = Nothing

			'Text2
			Set Options_SlideText = CSlideText(Options.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_2))
			Options_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_2)
			Set Options_SlideText = Nothing

			'Text1
			Set Options_SlideText = CSlideText(Options.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			Options_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_1)
			Set Options_SlideText = Nothing

	End Select

		Select Case Response.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t


			'Text3
			Set Response_SlideText = CSlideText(Response.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_3))
			Response_SlideText.Text = c.GetAttrib(ebUCase_C & ebLCase_e & ebLCase_r & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n)
			Set Response_SlideText = Nothing

			'Text2
			Set Response_SlideText = CSlideText(Response.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_2))
			Response_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_2)
			Set Response_SlideText = Nothing

			'Text1
			Set Response_SlideText = CSlideText(Response.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			Response_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_1)
			Set Response_SlideText = Nothing

	End Select




	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn BEGIN <PulseOn>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn END
	'''''''''''''''''''''''''''''''''''''''''''''


	Options.Run

	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetDelay, Options.OnsetDelay
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetTime, Options.OnsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameDurationError, Options.DurationError
	c.SetAttrib Options.Name & ebDot & ebLogNameDuration, Options.Duration
	c.SetAttrib Options.Name & ebDot & ebLogNameOffsetTime, Options.OffsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameRTTime, Options.RTTime
	c.SetAttrib Options.Name & ebDot & ebLogNameACC, Options.ACC
	c.SetAttrib Options.Name & ebDot & ebLogNameRT, Options.RT
	c.SetAttrib Options.Name & ebDot & ebLogNameRESP, Options.RESP
	c.SetAttrib Options.Name & ebDot & ebLogNameCRESP, Options.CRESP
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetToOnsetTime, Options.OnsetToOnsetTime



	Response.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		ResponseEchoClients.RemoveAll
		Response.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1 & ebDigit_2, ebDigit_1, CLng(Response.Duration), CLng(ebDigit_1), ebEndResponseActionNone, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	Response.Run

	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetDelay, Response.OnsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetTime, Response.OnsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameDurationError, Response.DurationError
	c.SetAttrib Response.Name & ebDot & ebLogNameDuration, Response.Duration
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetTime, Response.OffsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetDelay, Response.OffsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameRTTime, Response.RTTime
	c.SetAttrib Response.Name & ebDot & ebLogNameACC, Response.ACC
	c.SetAttrib Response.Name & ebDot & ebLogNameRT, Response.RT
	c.SetAttrib Response.Name & ebDot & ebLogNameRESP, Response.RESP
	c.SetAttrib Response.Name & ebDot & ebLogNameCRESP, Response.CRESP
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetToOnsetTime, Response.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff BEGIN <PulseOff>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff END
	'''''''''''''''''''''''''''''''''''''''''''''


	ISI.Run
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetDelay, ISI.OnsetDelay
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetTime, ISI.OnsetTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameDurationError, ISI.DurationError
	c.SetAttrib ISI.Name & ebDot & ebLogNameRTTime, ISI.RTTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameACC, ISI.ACC
	c.SetAttrib ISI.Name & ebDot & ebLogNameRT, ISI.RT
	c.SetAttrib ISI.Name & ebDot & ebLogNameRESP, ISI.RESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameCRESP, ISI.CRESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetToOnsetTime, ISI.OnsetToOnsetTime


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Feedback_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Feedback_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Feedback_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing the input object pending any input masks.
	' To prevent this code from being generated, set the Feedback object's
	'.ProcessInputObjectPendingInputMasks property to No/False.
	'
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		'Input Masks still pending?
		If Not Response.InputMasks.IsPending() Then
			Exit Do
		End If

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop
	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	'Determine if there are any InputMasks with a ebTimeLimitUntilFeedback set
	For BothFB_ChildIterator = 1 To LABothGain.ChildObjectCount
		Set BothFB_Child = CRteRunnableInputObject(Rte.GetObject(LABothGain.GetChildObjectName(BothFB_ChildIterator)))
		If Not BothFB_Child Is Nothing Then

			'Have we reached this FeedbackDisplay?
			'(we do not terminate InputMask with ebTimeLimitUntilFeedback
			'  that occur after our FeedbackDisplay)
			If BothFB_Child.Name = BothFB.Name Then Exit For

			'Enumerate through each object and then through each InputMask
			'terminate any input masks that have ebTimeLimitUntilFeeback set
			For BothFB_MaskIterator = 1 To BothFB_Child.InputMasks.Count
				Set BothFB_Mask = BothFB_Child.InputMasks(BothFB_MaskIterator)
				If Not BothFB_Mask Is Nothing Then
					If BothFB_Mask.Status = ebStatusArmed Then
						If BothFB_Mask.TimeLimit = ebTimeLimitUntilFeedback Then
							BothFB_Mask.Terminate
						End If
					End If
				End If
			Next
		End If
	Next

	If Response.ACC = 1 Then
		'Set the ActiveState to Correct
		BothFB.ActiveState = "Correct"

		'Add an observation to the accuracy stats
		BothFB.AccStats.AddObservation Response.Acc

		'Add an observation to the response time stats
		' unless the user did not respond and the author
		' does not want us to add the no response RT
		If Len(Response.RESP) > 0 Then
			BothFB.RTStats.AddObservation Response.RT
			BothFB.CorrectRTStats.AddObservation Response.RT
		End If
	Else
		'Is it incorrect or no response?
		If Len(Response.RESP) > 0 Then
			'Set the ActiveState to Incorrect
			BothFB.ActiveState = "Incorrect"

			'Set the accuracy stats
			BothFB.AccStats.AddObservation Response.Acc

			'Set the RT stats
			BothFB.RTStats.AddObservation Response.RT
			BothFB.IncorrectRTStats.AddObservation Response.RT
		Else
			'Set the ActiveState to NoResponse
			BothFB.ActiveState = "NoResponse"

			'Does the author want to consider a NoResponse
			' to sum as an incorrect response in the ACC stats?
			If BothFB.CollectNoRespACCStats = True Then
				BothFB.AccStats.AddObservation Response.Acc
			End If
		End If
	End If


	Select Case BothFB.ActiveState
		Case ebUCase_C & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t


			'Text1
			Set BothFB_SlideText = CSlideText(BothFB.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			BothFB_SlideText.Text = "You and " &_
				c.GetAttrib("PartnerName") &_
				" " &_
				c.GetAttrib("GambleOutcome") &_
				" " &_
				c.GetAttrib("GambleAmount")
			Set BothFB_SlideText = Nothing

		Case ebUCase_I & ebLCase_n & ebLCase_c & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t


			'Text1
			Set BothFB_SlideText = CSlideText(BothFB.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			BothFB_SlideText.Text = "You and " &_
				c.GetAttrib("PartnerName") &_
				" will receive the certain option of " &_
				c.GetAttrib("Certain")
			Set BothFB_SlideText = Nothing

	End Select



	BothFB.Run


	c.SetAttrib BothFB.Name & ebDot & ebLogNameOnsetDelay, BothFB.OnsetDelay
	c.SetAttrib BothFB.Name & ebDot & ebLogNameOnsetTime, BothFB.OnsetTime
	c.SetAttrib BothFB.Name & ebDot & ebLogNameDurationError, BothFB.DurationError
	c.SetAttrib BothFB.Name & ebDot & ebLogNameRTTime, BothFB.RTTime
	c.SetAttrib BothFB.Name & ebDot & ebLogNameACC, BothFB.ACC
	c.SetAttrib BothFB.Name & ebDot & ebLogNameRT, BothFB.RT
	c.SetAttrib BothFB.Name & ebDot & ebLogNameRESP, BothFB.RESP
	c.SetAttrib BothFB.Name & ebDot & ebLogNameCRESP, BothFB.CRESP
	c.SetAttrib BothFB.Name & ebDot & ebLogNameOnsetToOnsetTime, BothFB.OnsetToOnsetTime


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Feedback_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Feedback_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Feedback_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	ITI.Duration = CLng(c.GetAttrib(ebUCase_I & ebUCase_T & ebUCase_I & ebLCase_l & ebLCase_e & ebLCase_n & ebLCase_g & ebLCase_t & ebLCase_h))
	ITI.Run
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetDelay, ITI.OnsetDelay
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetTime, ITI.OnsetTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameDurationError, ITI.DurationError
	c.SetAttrib ITI.Name & ebDot & ebLogNameRTTime, ITI.RTTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameACC, ITI.ACC
	c.SetAttrib ITI.Name & ebDot & ebLogNameRT, ITI.RT
	c.SetAttrib ITI.Name & ebDot & ebLogNameRESP, ITI.RESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameCRESP, ITI.CRESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetToOnsetTime, ITI.OnsetToOnsetTime

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	LABothGain_theCollection.RemoveAll
	For LABothGain_nObject = 1 To LABothGain.ChildObjectCount
		Set LABothGain_theInputObject = CRteRunnableInputObject(Rte.GetObject(LABothGain.GetChildObjectName(LABothGain_nObject)))
		If Not LABothGain_theInputObject Is Nothing Then LABothGain_theCollection.Add LABothGain_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		LABothGain_bCanExit = True
		For LABothGain_nObject = 1 To LABothGain_theCollection.Count
			Set LABothGain_theInputObject = CRteRunnableInputObject(LABothGain_theCollection(LABothGain_nObject))
			If Not LABothGain_theInputObject Is Nothing Then
				If LABothGain_theInputObject.InputMasks.IsPending() Then
					LABothGain_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If LABothGain_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	LABothGain_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Options.EndOfProcedure

	Response.EndOfProcedure

	ISI.EndOfProcedure

	BothFB.EndOfProcedure

	ITI.EndOfProcedure

	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetDelay, Options.OnsetDelay
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetTime, Options.OnsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameDurationError, Options.DurationError
	c.SetAttrib Options.Name & ebDot & ebLogNameDuration, Options.Duration
	c.SetAttrib Options.Name & ebDot & ebLogNameOffsetTime, Options.OffsetTime
	c.SetAttrib Options.Name & ebDot & ebLogNameRTTime, Options.RTTime
	c.SetAttrib Options.Name & ebDot & ebLogNameACC, Options.ACC
	c.SetAttrib Options.Name & ebDot & ebLogNameRT, Options.RT
	c.SetAttrib Options.Name & ebDot & ebLogNameRESP, Options.RESP
	c.SetAttrib Options.Name & ebDot & ebLogNameCRESP, Options.CRESP
	c.SetAttrib Options.Name & ebDot & ebLogNameOnsetToOnsetTime, Options.OnsetToOnsetTime

	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetDelay, Response.OnsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetTime, Response.OnsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameDurationError, Response.DurationError
	c.SetAttrib Response.Name & ebDot & ebLogNameDuration, Response.Duration
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetTime, Response.OffsetTime
	c.SetAttrib Response.Name & ebDot & ebLogNameOffsetDelay, Response.OffsetDelay
	c.SetAttrib Response.Name & ebDot & ebLogNameRTTime, Response.RTTime
	c.SetAttrib Response.Name & ebDot & ebLogNameACC, Response.ACC
	c.SetAttrib Response.Name & ebDot & ebLogNameRT, Response.RT
	c.SetAttrib Response.Name & ebDot & ebLogNameRESP, Response.RESP
	c.SetAttrib Response.Name & ebDot & ebLogNameCRESP, Response.CRESP
	c.SetAttrib Response.Name & ebDot & ebLogNameOnsetToOnsetTime, Response.OnsetToOnsetTime

	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetDelay, ISI.OnsetDelay
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetTime, ISI.OnsetTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameDurationError, ISI.DurationError
	c.SetAttrib ISI.Name & ebDot & ebLogNameRTTime, ISI.RTTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameACC, ISI.ACC
	c.SetAttrib ISI.Name & ebDot & ebLogNameRT, ISI.RT
	c.SetAttrib ISI.Name & ebDot & ebLogNameRESP, ISI.RESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameCRESP, ISI.CRESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetToOnsetTime, ISI.OnsetToOnsetTime

	c.SetAttrib BothFB.Name & ebDot & ebLogNameOnsetDelay, BothFB.OnsetDelay
	c.SetAttrib BothFB.Name & ebDot & ebLogNameOnsetTime, BothFB.OnsetTime
	c.SetAttrib BothFB.Name & ebDot & ebLogNameDurationError, BothFB.DurationError
	c.SetAttrib BothFB.Name & ebDot & ebLogNameRTTime, BothFB.RTTime
	c.SetAttrib BothFB.Name & ebDot & ebLogNameACC, BothFB.ACC
	c.SetAttrib BothFB.Name & ebDot & ebLogNameRT, BothFB.RT
	c.SetAttrib BothFB.Name & ebDot & ebLogNameRESP, BothFB.RESP
	c.SetAttrib BothFB.Name & ebDot & ebLogNameCRESP, BothFB.CRESP
	c.SetAttrib BothFB.Name & ebDot & ebLogNameOnsetToOnsetTime, BothFB.OnsetToOnsetTime

	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetDelay, ITI.OnsetDelay
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetTime, ITI.OnsetTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameDurationError, ITI.DurationError
	c.SetAttrib ITI.Name & ebDot & ebLogNameRTTime, ITI.RTTime
	c.SetAttrib ITI.Name & ebDot & ebLogNameACC, ITI.ACC
	c.SetAttrib ITI.Name & ebDot & ebLogNameRT, ITI.RT
	c.SetAttrib ITI.Name & ebDot & ebLogNameRESP, ITI.RESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameCRESP, ITI.CRESP
	c.SetAttrib ITI.Name & ebDot & ebLogNameOnsetToOnsetTime, ITI.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub













Sub PracticeTrials_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		List14.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	PracticeTrials_theCollection.RemoveAll
	For PracticeTrials_nObject = 1 To PracticeTrials.ChildObjectCount
		Set PracticeTrials_theInputObject = CRteRunnableInputObject(Rte.GetObject(PracticeTrials.GetChildObjectName(PracticeTrials_nObject)))
		If Not PracticeTrials_theInputObject Is Nothing Then PracticeTrials_theCollection.Add PracticeTrials_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		PracticeTrials_bCanExit = True
		For PracticeTrials_nObject = 1 To PracticeTrials_theCollection.Count
			Set PracticeTrials_theInputObject = CRteRunnableInputObject(PracticeTrials_theCollection(PracticeTrials_nObject))
			If Not PracticeTrials_theInputObject Is Nothing Then
				If PracticeTrials_theInputObject.InputMasks.IsPending() Then
					PracticeTrials_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If PracticeTrials_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	PracticeTrials_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub PracticeMixed_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		practiceoptions.ResetLoggingProperties
		practiceresponse.ResetLoggingProperties
		ISI.ResetLoggingProperties
		ITIPrac.ResetLoggingProperties
		Select Case practiceoptions.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t


			'Text3
			Set practiceoptions_SlideText = CSlideText(practiceoptions.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_3))
			practiceoptions_SlideText.Text = c.GetAttrib(ebUCase_C & ebLCase_e & ebLCase_r & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n)
			Set practiceoptions_SlideText = Nothing

			'Text2
			Set practiceoptions_SlideText = CSlideText(practiceoptions.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_2))
			practiceoptions_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_2)
			Set practiceoptions_SlideText = Nothing

			'Text1
			Set practiceoptions_SlideText = CSlideText(practiceoptions.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			practiceoptions_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_1)
			Set practiceoptions_SlideText = Nothing

	End Select

		Select Case practiceresponse.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t


			'Text3
			Set practiceresponse_SlideText = CSlideText(practiceresponse.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_3))
			practiceresponse_SlideText.Text = c.GetAttrib(ebUCase_C & ebLCase_e & ebLCase_r & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n)
			Set practiceresponse_SlideText = Nothing

			'Text2
			Set practiceresponse_SlideText = CSlideText(practiceresponse.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_2))
			practiceresponse_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_2)
			Set practiceresponse_SlideText = Nothing

			'Text1
			Set practiceresponse_SlideText = CSlideText(practiceresponse.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			practiceresponse_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_1)
			Set practiceresponse_SlideText = Nothing

	End Select




	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	practiceoptions.Run



	practiceresponse.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		practiceresponseEchoClients.RemoveAll
		practiceresponse.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1 & ebDigit_2, ebDigit_1, CLng(practiceresponse.Duration), CLng(ebDigit_1), ebEndResponseActionNone, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	practiceresponse.Run


	ISI.Run
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetDelay, ISI.OnsetDelay
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetTime, ISI.OnsetTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameDurationError, ISI.DurationError
	c.SetAttrib ISI.Name & ebDot & ebLogNameRTTime, ISI.RTTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameACC, ISI.ACC
	c.SetAttrib ISI.Name & ebDot & ebLogNameRT, ISI.RT
	c.SetAttrib ISI.Name & ebDot & ebLogNameRESP, ISI.RESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameCRESP, ISI.CRESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetToOnsetTime, ISI.OnsetToOnsetTime


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Feedback_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Feedback_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Feedback_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing the input object pending any input masks.
	' To prevent this code from being generated, set the Feedback object's
	'.ProcessInputObjectPendingInputMasks property to No/False.
	'
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		'Input Masks still pending?
		If Not practiceresponse.InputMasks.IsPending() Then
			Exit Do
		End If

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop
	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	'Determine if there are any InputMasks with a ebTimeLimitUntilFeedback set
	For FeedbackDisplay2_ChildIterator = 1 To PracticeMixed.ChildObjectCount
		Set FeedbackDisplay2_Child = CRteRunnableInputObject(Rte.GetObject(PracticeMixed.GetChildObjectName(FeedbackDisplay2_ChildIterator)))
		If Not FeedbackDisplay2_Child Is Nothing Then

			'Have we reached this FeedbackDisplay?
			'(we do not terminate InputMask with ebTimeLimitUntilFeedback
			'  that occur after our FeedbackDisplay)
			If FeedbackDisplay2_Child.Name = FeedbackDisplay2.Name Then Exit For

			'Enumerate through each object and then through each InputMask
			'terminate any input masks that have ebTimeLimitUntilFeeback set
			For FeedbackDisplay2_MaskIterator = 1 To FeedbackDisplay2_Child.InputMasks.Count
				Set FeedbackDisplay2_Mask = FeedbackDisplay2_Child.InputMasks(FeedbackDisplay2_MaskIterator)
				If Not FeedbackDisplay2_Mask Is Nothing Then
					If FeedbackDisplay2_Mask.Status = ebStatusArmed Then
						If FeedbackDisplay2_Mask.TimeLimit = ebTimeLimitUntilFeedback Then
							FeedbackDisplay2_Mask.Terminate
						End If
					End If
				End If
			Next
		End If
	Next

	If practiceresponse.ACC = 1 Then
		'Set the ActiveState to Correct
		FeedbackDisplay2.ActiveState = "Correct"

		'Add an observation to the accuracy stats
		FeedbackDisplay2.AccStats.AddObservation practiceresponse.Acc

		'Add an observation to the response time stats
		' unless the user did not respond and the author
		' does not want us to add the no response RT
		If Len(practiceresponse.RESP) > 0 Then
			FeedbackDisplay2.RTStats.AddObservation practiceresponse.RT
			FeedbackDisplay2.CorrectRTStats.AddObservation practiceresponse.RT
		End If
	Else
		'Is it incorrect or no response?
		If Len(practiceresponse.RESP) > 0 Then
			'Set the ActiveState to Incorrect
			FeedbackDisplay2.ActiveState = "Incorrect"

			'Set the accuracy stats
			FeedbackDisplay2.AccStats.AddObservation practiceresponse.Acc

			'Set the RT stats
			FeedbackDisplay2.RTStats.AddObservation practiceresponse.RT
			FeedbackDisplay2.IncorrectRTStats.AddObservation practiceresponse.RT
		Else
			'Set the ActiveState to NoResponse
			FeedbackDisplay2.ActiveState = "NoResponse"

			'Does the author want to consider a NoResponse
			' to sum as an incorrect response in the ACC stats?
			If FeedbackDisplay2.CollectNoRespACCStats = True Then
				FeedbackDisplay2.AccStats.AddObservation practiceresponse.Acc
			End If
		End If
	End If


	Select Case FeedbackDisplay2.ActiveState
		Case ebUCase_C & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t


			'Text1
			Set FeedbackDisplay2_SlideText = CSlideText(FeedbackDisplay2.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			FeedbackDisplay2_SlideText.Text = "You " &_
				c.GetAttrib("GambleOutcome") &_
				" " &_
				c.GetAttrib("GambleAmount")
			Set FeedbackDisplay2_SlideText = Nothing

		Case ebUCase_I & ebLCase_n & ebLCase_c & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t


			'Text1
			Set FeedbackDisplay2_SlideText = CSlideText(FeedbackDisplay2.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			FeedbackDisplay2_SlideText.Text = "You chose the certain option of " &_
				c.GetAttrib("Certain")
			Set FeedbackDisplay2_SlideText = Nothing

	End Select



	FeedbackDisplay2.Run



	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Feedback_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Feedback_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Feedback_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	ITIPrac.Run
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	PracticeMixed_theCollection.RemoveAll
	For PracticeMixed_nObject = 1 To PracticeMixed.ChildObjectCount
		Set PracticeMixed_theInputObject = CRteRunnableInputObject(Rte.GetObject(PracticeMixed.GetChildObjectName(PracticeMixed_nObject)))
		If Not PracticeMixed_theInputObject Is Nothing Then PracticeMixed_theCollection.Add PracticeMixed_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		PracticeMixed_bCanExit = True
		For PracticeMixed_nObject = 1 To PracticeMixed_theCollection.Count
			Set PracticeMixed_theInputObject = CRteRunnableInputObject(PracticeMixed_theCollection(PracticeMixed_nObject))
			If Not PracticeMixed_theInputObject Is Nothing Then
				If PracticeMixed_theInputObject.InputMasks.IsPending() Then
					PracticeMixed_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If PracticeMixed_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	PracticeMixed_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	practiceoptions.EndOfProcedure

	practiceresponse.EndOfProcedure

	ISI.EndOfProcedure

	FeedbackDisplay2.EndOfProcedure

	ITIPrac.EndOfProcedure

	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetDelay, ISI.OnsetDelay
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetTime, ISI.OnsetTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameDurationError, ISI.DurationError
	c.SetAttrib ISI.Name & ebDot & ebLogNameRTTime, ISI.RTTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameACC, ISI.ACC
	c.SetAttrib ISI.Name & ebDot & ebLogNameRT, ISI.RT
	c.SetAttrib ISI.Name & ebDot & ebLogNameRESP, ISI.RESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameCRESP, ISI.CRESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetToOnsetTime, ISI.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub PracticeGain_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		practiceoptions3.ResetLoggingProperties
		practiceresponse3.ResetLoggingProperties
		ISI.ResetLoggingProperties
		ITIPrac.ResetLoggingProperties
		Select Case practiceoptions3.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t


			'Text3
			Set practiceoptions3_SlideText = CSlideText(practiceoptions3.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_3))
			practiceoptions3_SlideText.Text = c.GetAttrib(ebUCase_C & ebLCase_e & ebLCase_r & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n)
			Set practiceoptions3_SlideText = Nothing

			'Text2
			Set practiceoptions3_SlideText = CSlideText(practiceoptions3.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_2))
			practiceoptions3_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_2)
			Set practiceoptions3_SlideText = Nothing

			'Text1
			Set practiceoptions3_SlideText = CSlideText(practiceoptions3.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			practiceoptions3_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_1)
			Set practiceoptions3_SlideText = Nothing

	End Select

		Select Case practiceresponse3.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t


			'Text3
			Set practiceresponse3_SlideText = CSlideText(practiceresponse3.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_3))
			practiceresponse3_SlideText.Text = c.GetAttrib(ebUCase_C & ebLCase_e & ebLCase_r & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n)
			Set practiceresponse3_SlideText = Nothing

			'Text2
			Set practiceresponse3_SlideText = CSlideText(practiceresponse3.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_2))
			practiceresponse3_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_2)
			Set practiceresponse3_SlideText = Nothing

			'Text1
			Set practiceresponse3_SlideText = CSlideText(practiceresponse3.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			practiceresponse3_SlideText.Text = c.GetAttrib(ebUCase_A & ebLCase_m & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebDigit_1)
			Set practiceresponse3_SlideText = Nothing

	End Select




	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	practiceoptions3.Run



	practiceresponse3.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		practiceresponse3EchoClients.RemoveAll
		practiceresponse3.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1 & ebDigit_2, ebDigit_1, CLng(practiceresponse3.Duration), CLng(ebDigit_1), ebEndResponseActionNone, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	practiceresponse3.Run


	ISI.Run
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetDelay, ISI.OnsetDelay
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetTime, ISI.OnsetTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameDurationError, ISI.DurationError
	c.SetAttrib ISI.Name & ebDot & ebLogNameRTTime, ISI.RTTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameACC, ISI.ACC
	c.SetAttrib ISI.Name & ebDot & ebLogNameRT, ISI.RT
	c.SetAttrib ISI.Name & ebDot & ebLogNameRESP, ISI.RESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameCRESP, ISI.CRESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetToOnsetTime, ISI.OnsetToOnsetTime


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Feedback_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Feedback_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Feedback_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing the input object pending any input masks.
	' To prevent this code from being generated, set the Feedback object's
	'.ProcessInputObjectPendingInputMasks property to No/False.
	'
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		'Input Masks still pending?
		If Not practiceresponse3.InputMasks.IsPending() Then
			Exit Do
		End If

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop
	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	'Determine if there are any InputMasks with a ebTimeLimitUntilFeedback set
	For FeedbackDisplay4_ChildIterator = 1 To PracticeGain.ChildObjectCount
		Set FeedbackDisplay4_Child = CRteRunnableInputObject(Rte.GetObject(PracticeGain.GetChildObjectName(FeedbackDisplay4_ChildIterator)))
		If Not FeedbackDisplay4_Child Is Nothing Then

			'Have we reached this FeedbackDisplay?
			'(we do not terminate InputMask with ebTimeLimitUntilFeedback
			'  that occur after our FeedbackDisplay)
			If FeedbackDisplay4_Child.Name = FeedbackDisplay4.Name Then Exit For

			'Enumerate through each object and then through each InputMask
			'terminate any input masks that have ebTimeLimitUntilFeeback set
			For FeedbackDisplay4_MaskIterator = 1 To FeedbackDisplay4_Child.InputMasks.Count
				Set FeedbackDisplay4_Mask = FeedbackDisplay4_Child.InputMasks(FeedbackDisplay4_MaskIterator)
				If Not FeedbackDisplay4_Mask Is Nothing Then
					If FeedbackDisplay4_Mask.Status = ebStatusArmed Then
						If FeedbackDisplay4_Mask.TimeLimit = ebTimeLimitUntilFeedback Then
							FeedbackDisplay4_Mask.Terminate
						End If
					End If
				End If
			Next
		End If
	Next

	If practiceresponse3.ACC = 1 Then
		'Set the ActiveState to Correct
		FeedbackDisplay4.ActiveState = "Correct"

		'Add an observation to the accuracy stats
		FeedbackDisplay4.AccStats.AddObservation practiceresponse3.Acc

		'Add an observation to the response time stats
		' unless the user did not respond and the author
		' does not want us to add the no response RT
		If Len(practiceresponse3.RESP) > 0 Then
			FeedbackDisplay4.RTStats.AddObservation practiceresponse3.RT
			FeedbackDisplay4.CorrectRTStats.AddObservation practiceresponse3.RT
		End If
	Else
		'Is it incorrect or no response?
		If Len(practiceresponse3.RESP) > 0 Then
			'Set the ActiveState to Incorrect
			FeedbackDisplay4.ActiveState = "Incorrect"

			'Set the accuracy stats
			FeedbackDisplay4.AccStats.AddObservation practiceresponse3.Acc

			'Set the RT stats
			FeedbackDisplay4.RTStats.AddObservation practiceresponse3.RT
			FeedbackDisplay4.IncorrectRTStats.AddObservation practiceresponse3.RT
		Else
			'Set the ActiveState to NoResponse
			FeedbackDisplay4.ActiveState = "NoResponse"

			'Does the author want to consider a NoResponse
			' to sum as an incorrect response in the ACC stats?
			If FeedbackDisplay4.CollectNoRespACCStats = True Then
				FeedbackDisplay4.AccStats.AddObservation practiceresponse3.Acc
			End If
		End If
	End If


	Select Case FeedbackDisplay4.ActiveState
		Case ebUCase_C & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t


			'Text1
			Set FeedbackDisplay4_SlideText = CSlideText(FeedbackDisplay4.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			FeedbackDisplay4_SlideText.Text = "You " &_
				c.GetAttrib("GambleOutcome") &_
				" " &_
				c.GetAttrib("GambleAmount")
			Set FeedbackDisplay4_SlideText = Nothing

		Case ebUCase_I & ebLCase_n & ebLCase_c & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t


			'Text1
			Set FeedbackDisplay4_SlideText = CSlideText(FeedbackDisplay4.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1))
			FeedbackDisplay4_SlideText.Text = "You chose the certain option of " &_
				c.GetAttrib("Certain")
			Set FeedbackDisplay4_SlideText = Nothing

	End Select



	FeedbackDisplay4.Run



	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Feedback_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Feedback_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Feedback_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Feedback_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	ITIPrac.Run
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	PracticeGain_theCollection.RemoveAll
	For PracticeGain_nObject = 1 To PracticeGain.ChildObjectCount
		Set PracticeGain_theInputObject = CRteRunnableInputObject(Rte.GetObject(PracticeGain.GetChildObjectName(PracticeGain_nObject)))
		If Not PracticeGain_theInputObject Is Nothing Then PracticeGain_theCollection.Add PracticeGain_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		PracticeGain_bCanExit = True
		For PracticeGain_nObject = 1 To PracticeGain_theCollection.Count
			Set PracticeGain_theInputObject = CRteRunnableInputObject(PracticeGain_theCollection(PracticeGain_nObject))
			If Not PracticeGain_theInputObject Is Nothing Then
				If PracticeGain_theInputObject.InputMasks.IsPending() Then
					PracticeGain_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If PracticeGain_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	PracticeGain_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	practiceoptions3.EndOfProcedure

	practiceresponse3.EndOfProcedure

	ISI.EndOfProcedure

	FeedbackDisplay4.EndOfProcedure

	ITIPrac.EndOfProcedure

	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetDelay, ISI.OnsetDelay
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetTime, ISI.OnsetTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameDurationError, ISI.DurationError
	c.SetAttrib ISI.Name & ebDot & ebLogNameRTTime, ISI.RTTime
	c.SetAttrib ISI.Name & ebDot & ebLogNameACC, ISI.ACC
	c.SetAttrib ISI.Name & ebDot & ebLogNameRT, ISI.RT
	c.SetAttrib ISI.Name & ebDot & ebLogNameRESP, ISI.RESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameCRESP, ISI.CRESP
	c.SetAttrib ISI.Name & ebDot & ebLogNameOnsetToOnsetTime, ISI.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub













Sub selfratings_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		SelfOutcomes.ResetLoggingProperties
		Select Case SelfOutcomes.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t


			'Text11
			Set SelfOutcomes_SlideText = CSlideText(SelfOutcomes.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1 & ebDigit_1))
			SelfOutcomes_SlideText.Text = "How did you feel when " &_
				c.GetAttrib("RatingOutcome") &_
				" money for yourself?"
			Set SelfOutcomes_SlideText = Nothing

	End Select


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Init BEGIN <Init>
	'''''''''''''''''''''''''''''''''''''''''''''
	'Declare string variables to hold information about the currently selected box
'and the previously selected box.
Dim intCurrent As Integer, intPrevious As Integer

'Default values.
intCurrent = 4
intCurrent = 4
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Init END
	'''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - SelectAgain BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

SelectAgain:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume SelectAgainResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

SelectAgainResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - SelectAgain END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	SelfOutcomes.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		SelfOutcomesEchoClients.RemoveAll
		SelfOutcomes.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1 & ebDigit_2 & ebDigit_3, ebEmptyText, CLng(SelfOutcomes.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	SelfOutcomes.Run

	c.SetAttrib SelfOutcomes.Name & ebDot & ebLogNameOnsetDelay, SelfOutcomes.OnsetDelay
	c.SetAttrib SelfOutcomes.Name & ebDot & ebLogNameOnsetTime, SelfOutcomes.OnsetTime
	c.SetAttrib SelfOutcomes.Name & ebDot & ebLogNameDurationError, SelfOutcomes.DurationError
	c.SetAttrib SelfOutcomes.Name & ebDot & ebLogNameRTTime, SelfOutcomes.RTTime
	c.SetAttrib SelfOutcomes.Name & ebDot & ebLogNameACC, SelfOutcomes.ACC
	c.SetAttrib SelfOutcomes.Name & ebDot & ebLogNameRT, SelfOutcomes.RT
	c.SetAttrib SelfOutcomes.Name & ebDot & ebLogNameRESP, SelfOutcomes.RESP
	c.SetAttrib SelfOutcomes.Name & ebDot & ebLogNameCRESP, SelfOutcomes.CRESP
	c.SetAttrib SelfOutcomes.Name & ebDot & ebLogNameOnsetToOnsetTime, SelfOutcomes.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - SelfAdjustScale BEGIN <SelfAdjustScale>
	'''''''''''''''''''''''''''''''''''''''''''''
	'Declare a variable for accessing each SlideText object and changing properties.
Dim theSlideText As SlideText

Dim strName As String

'Was there a response?
If SelfOutcomes.InputMasks.Responses.Count > 0 Then

		If SelfOutcomes.RESP = "3" Then

			'Subject has already selected the highest rating.
			If intCurrent >= 7 Then
			   GoTo SelectAgain

			End If

			'Increment the current selection.
			intPrevious = intCurrent
			intCurrent = intCurrent + 1

			'Change border color of previously selected box back to black, change border
			'color of currently selected box to white.
			strName = "Text" & intPrevious
			Set theSlideText = CSlideText(SelfOutcomes.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("black")

			strName = "Text" & intCurrent
			Set theSlideText = CSlideText(SelfOutcomes.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("white")

			'Return to the SelfOutcomes object to collect another response.
			GoTo SelectAgain

	ElseIf SelfOutcomes.RESP = "1" Then

			'Subject has already selected the lowest rating.
			If intCurrent <= 1 Then
				GoTo SelectAgain
			End If

			'Decrement the current selection.
			intPrevious = intCurrent
			intCurrent = intCurrent - 1

			'Change border color of previously selected box back to black, change border
			'color of currently selected box to white.
			strName = "Text" & intPrevious
			Set theSlideText = CSlideText(SelfOutcomes.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("black")

			strName = "Text" & intCurrent
			Set theSlideText = CSlideText(SelfOutcomes.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("white")

			'Return to the SelfOutcomes object to collect another response.
			GoTo SelectAgain

		ElseIf SelfOutcomes.RESP = "2" Then

			'Change the BackColor property of the selected box to white to show the subject
			'that the response has been collected.
			strName = "Text" & intCurrent
			Set theSlideText = CSlideText(SelfOutcomes.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("red")

			'Redraw the Slide to show changes.
			SelfOutcomes.Draw

			'Log rating in the data file under the attribute "Rating"
			c.SetAttrib "Rating", intCurrent

			Sleep 1000

			'Return box to default appearance.
			theSlideText.BackColor = CColor("black")
			theSlideText.BorderColor = CColor("black")

			strName = "Text4"
			Set theSlideText = CSlideText(SelfOutcomes.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("white")


		End If

'The subject did not respond.
Else
	c.SetAttrib "Rating", "nothing"

End If

Set theSlideText = Nothing
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - SelfAdjustScale END
	'''''''''''''''''''''''''''''''''''''''''''''

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	selfratings_theCollection.RemoveAll
	For selfratings_nObject = 1 To selfratings.ChildObjectCount
		Set selfratings_theInputObject = CRteRunnableInputObject(Rte.GetObject(selfratings.GetChildObjectName(selfratings_nObject)))
		If Not selfratings_theInputObject Is Nothing Then selfratings_theCollection.Add selfratings_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		selfratings_bCanExit = True
		For selfratings_nObject = 1 To selfratings_theCollection.Count
			Set selfratings_theInputObject = CRteRunnableInputObject(selfratings_theCollection(selfratings_nObject))
			If Not selfratings_theInputObject Is Nothing Then
				If selfratings_theInputObject.InputMasks.IsPending() Then
					selfratings_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If selfratings_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	selfratings_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	SelfOutcomes.EndOfProcedure

	c.SetAttrib SelfOutcomes.Name & ebDot & ebLogNameOnsetDelay, SelfOutcomes.OnsetDelay
	c.SetAttrib SelfOutcomes.Name & ebDot & ebLogNameOnsetTime, SelfOutcomes.OnsetTime
	c.SetAttrib SelfOutcomes.Name & ebDot & ebLogNameDurationError, SelfOutcomes.DurationError
	c.SetAttrib SelfOutcomes.Name & ebDot & ebLogNameRTTime, SelfOutcomes.RTTime
	c.SetAttrib SelfOutcomes.Name & ebDot & ebLogNameACC, SelfOutcomes.ACC
	c.SetAttrib SelfOutcomes.Name & ebDot & ebLogNameRT, SelfOutcomes.RT
	c.SetAttrib SelfOutcomes.Name & ebDot & ebLogNameRESP, SelfOutcomes.RESP
	c.SetAttrib SelfOutcomes.Name & ebDot & ebLogNameCRESP, SelfOutcomes.CRESP
	c.SetAttrib SelfOutcomes.Name & ebDot & ebLogNameOnsetToOnsetTime, SelfOutcomes.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub otherratings_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		OtherOutcomes.ResetLoggingProperties
		Select Case OtherOutcomes.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t


			'Text8
			Set OtherOutcomes_SlideText = CSlideText(OtherOutcomes.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_8))
			OtherOutcomes_SlideText.Text = "How did you feel when " &_
				c.GetAttrib("RatingOutcome") &_
				" money for " &_
				c.GetAttrib("PartnerName") &_
				"?"
			Set OtherOutcomes_SlideText = Nothing

	End Select


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Init BEGIN <Init>
	'''''''''''''''''''''''''''''''''''''''''''''
	'Declare string variables to hold information about the currently selected box
'and the previously selected box.
Dim intCurrent As Integer, intPrevious As Integer

'Default values.
intCurrent = 4
intCurrent = 4
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Init END
	'''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - SelectAgain BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

SelectAgain:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume SelectAgainResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

SelectAgainResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - SelectAgain END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	OtherOutcomes.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		OtherOutcomesEchoClients.RemoveAll
		OtherOutcomes.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1 & ebDigit_2 & ebDigit_3, ebEmptyText, CLng(OtherOutcomes.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	OtherOutcomes.Run


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - OtherAdjustScale BEGIN <OtherAdjustScale>
	'''''''''''''''''''''''''''''''''''''''''''''
	'Declare a variable for accessing each SlideText object and changing properties.
Dim theSlideText As SlideText

Dim strName As String

'Was there a response?
If OtherOutcomes.InputMasks.Responses.Count > 0 Then

		If OtherOutcomes.RESP = "3" Then

			'Subject has already selected the highest rating.
			If intCurrent >= 7 Then
			   GoTo SelectAgain

			End If

			'Increment the current selection.
			intPrevious = intCurrent
			intCurrent = intCurrent + 1

			'Change border color of previously selected box back to black, change border
			'color of currently selected box to white.
			strName = "Text" & intPrevious
			Set theSlideText = CSlideText(OtherOutcomes.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("black")

			strName = "Text" & intCurrent
			Set theSlideText = CSlideText(OtherOutcomes.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("white")

			'Return to the OtherOutcomes object to collect another response.
			GoTo SelectAgain

	ElseIf OtherOutcomes.RESP = "1" Then

			'Subject has already selected the lowest rating.
			If intCurrent <= 1 Then
				GoTo SelectAgain
			End If

			'Decrement the current selection.
			intPrevious = intCurrent
			intCurrent = intCurrent - 1

			'Change border color of previously selected box back to black, change border
			'color of currently selected box to white.
			strName = "Text" & intPrevious
			Set theSlideText = CSlideText(OtherOutcomes.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("black")

			strName = "Text" & intCurrent
			Set theSlideText = CSlideText(OtherOutcomes.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("white")

			'Return to the OtherOutcomes object to collect another response.
			GoTo SelectAgain

		ElseIf OtherOutcomes.RESP = "2" Then

			'Change the BackColor property of the selected box to white to show the subject
			'that the response has been collected.
			strName = "Text" & intCurrent
			Set theSlideText = CSlideText(OtherOutcomes.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("red")

			'Redraw the Slide to show changes.
			OtherOutcomes.Draw

			'Log rating in the data file under the attribute "Rating"
			c.SetAttrib "Rating", intCurrent

			Sleep 1000

			'Return box to default appearance.
			theSlideText.BackColor = CColor("black")
			theSlideText.BorderColor = CColor("black")

			strName = "Text4"
			Set theSlideText = CSlideText(OtherOutcomes.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("white")


		End If

'The subject did not respond.
Else
	c.SetAttrib "Rating", "nothing"

End If

Set theSlideText = Nothing
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - OtherAdjustScale END
	'''''''''''''''''''''''''''''''''''''''''''''

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	otherratings_theCollection.RemoveAll
	For otherratings_nObject = 1 To otherratings.ChildObjectCount
		Set otherratings_theInputObject = CRteRunnableInputObject(Rte.GetObject(otherratings.GetChildObjectName(otherratings_nObject)))
		If Not otherratings_theInputObject Is Nothing Then otherratings_theCollection.Add otherratings_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		otherratings_bCanExit = True
		For otherratings_nObject = 1 To otherratings_theCollection.Count
			Set otherratings_theInputObject = CRteRunnableInputObject(otherratings_theCollection(otherratings_nObject))
			If Not otherratings_theInputObject Is Nothing Then
				If otherratings_theInputObject.InputMasks.IsPending() Then
					otherratings_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If otherratings_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	otherratings_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	OtherOutcomes.EndOfProcedure


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub sharedratings_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		SharedOutcomes.ResetLoggingProperties
		Select Case SharedOutcomes.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t


			'Text12
			Set SharedOutcomes_SlideText = CSlideText(SharedOutcomes.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_1 & ebDigit_2))
			SharedOutcomes_SlideText.Text = "How did you feel when sharing " &_
				c.GetAttrib("RatingOutcome") &_
				" with " &_
				c.GetAttrib("PartnerName") &_
				"?"
			Set SharedOutcomes_SlideText = Nothing

	End Select


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Init BEGIN <Init>
	'''''''''''''''''''''''''''''''''''''''''''''
	'Declare string variables to hold information about the currently selected box
'and the previously selected box.
Dim intCurrent As Integer, intPrevious As Integer

'Default values.
intCurrent = 4
intCurrent = 4
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Init END
	'''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - SelectAgain BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

SelectAgain:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume SelectAgainResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

SelectAgainResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - SelectAgain END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	SharedOutcomes.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		SharedOutcomesEchoClients.RemoveAll
		SharedOutcomes.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1 & ebDigit_2 & ebDigit_3, ebEmptyText, CLng(SharedOutcomes.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	SharedOutcomes.Run

	c.SetAttrib SharedOutcomes.Name & ebDot & ebLogNameOnsetDelay, SharedOutcomes.OnsetDelay
	c.SetAttrib SharedOutcomes.Name & ebDot & ebLogNameOnsetTime, SharedOutcomes.OnsetTime
	c.SetAttrib SharedOutcomes.Name & ebDot & ebLogNameDurationError, SharedOutcomes.DurationError
	c.SetAttrib SharedOutcomes.Name & ebDot & ebLogNameRTTime, SharedOutcomes.RTTime
	c.SetAttrib SharedOutcomes.Name & ebDot & ebLogNameACC, SharedOutcomes.ACC
	c.SetAttrib SharedOutcomes.Name & ebDot & ebLogNameRT, SharedOutcomes.RT
	c.SetAttrib SharedOutcomes.Name & ebDot & ebLogNameRESP, SharedOutcomes.RESP
	c.SetAttrib SharedOutcomes.Name & ebDot & ebLogNameCRESP, SharedOutcomes.CRESP
	c.SetAttrib SharedOutcomes.Name & ebDot & ebLogNameOnsetToOnsetTime, SharedOutcomes.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - SharedAdjustScale BEGIN <SharedAdjustScale>
	'''''''''''''''''''''''''''''''''''''''''''''
	'Declare a variable for accessing each SlideText object and changing properties.
Dim theSlideText As SlideText

Dim strName As String

'Was there a response?
If SharedOutcomes.InputMasks.Responses.Count > 0 Then

		If SharedOutcomes.RESP = "3" Then

			'Subject has already selected the highest rating.
			If intCurrent >= 7 Then
			   GoTo SelectAgain

			End If

			'Increment the current selection.
			intPrevious = intCurrent
			intCurrent = intCurrent + 1

			'Change border color of previously selected box back to black, change border
			'color of currently selected box to white.
			strName = "Text" & intPrevious
			Set theSlideText = CSlideText(SharedOutcomes.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("black")

			strName = "Text" & intCurrent
			Set theSlideText = CSlideText(SharedOutcomes.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("white")

			'Return to the SharedOutcomes object to collect another response.
			GoTo SelectAgain

	ElseIf SharedOutcomes.RESP = "1" Then

			'Subject has already selected the lowest rating.
			If intCurrent <= 1 Then
				GoTo SelectAgain
			End If

			'Decrement the current selection.
			intPrevious = intCurrent
			intCurrent = intCurrent - 1

			'Change border color of previously selected box back to black, change border
			'color of currently selected box to white.
			strName = "Text" & intPrevious
			Set theSlideText = CSlideText(SharedOutcomes.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("black")

			strName = "Text" & intCurrent
			Set theSlideText = CSlideText(SharedOutcomes.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("white")

			'Return to the SharedOutcomes object to collect another response.
			GoTo SelectAgain

		ElseIf SharedOutcomes.RESP = "2" Then

			'Change the BackColor property of the selected box to white to show the subject
			'that the response has been collected.
			strName = "Text" & intCurrent
			Set theSlideText = CSlideText(SharedOutcomes.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("red")

			'Redraw the Slide to show changes.
			SharedOutcomes.Draw

			'Log rating in the data file under the attribute "Rating"
			c.SetAttrib "Rating", intCurrent

			Sleep 1000

			'Return box to default appearance.
			theSlideText.BackColor = CColor("black")
			theSlideText.BorderColor = CColor("black")

			strName = "Text4"
			Set theSlideText = CSlideText(SharedOutcomes.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("white")


		End If

'The subject did not respond.
Else
	c.SetAttrib "Rating", "nothing"

End If

Set theSlideText = Nothing
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - SharedAdjustScale END
	'''''''''''''''''''''''''''''''''''''''''''''

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	sharedratings_theCollection.RemoveAll
	For sharedratings_nObject = 1 To sharedratings.ChildObjectCount
		Set sharedratings_theInputObject = CRteRunnableInputObject(Rte.GetObject(sharedratings.GetChildObjectName(sharedratings_nObject)))
		If Not sharedratings_theInputObject Is Nothing Then sharedratings_theCollection.Add sharedratings_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		sharedratings_bCanExit = True
		For sharedratings_nObject = 1 To sharedratings_theCollection.Count
			Set sharedratings_theInputObject = CRteRunnableInputObject(sharedratings_theCollection(sharedratings_nObject))
			If Not sharedratings_theInputObject Is Nothing Then
				If sharedratings_theInputObject.InputMasks.IsPending() Then
					sharedratings_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If sharedratings_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	sharedratings_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	SharedOutcomes.EndOfProcedure

	c.SetAttrib SharedOutcomes.Name & ebDot & ebLogNameOnsetDelay, SharedOutcomes.OnsetDelay
	c.SetAttrib SharedOutcomes.Name & ebDot & ebLogNameOnsetTime, SharedOutcomes.OnsetTime
	c.SetAttrib SharedOutcomes.Name & ebDot & ebLogNameDurationError, SharedOutcomes.DurationError
	c.SetAttrib SharedOutcomes.Name & ebDot & ebLogNameRTTime, SharedOutcomes.RTTime
	c.SetAttrib SharedOutcomes.Name & ebDot & ebLogNameACC, SharedOutcomes.ACC
	c.SetAttrib SharedOutcomes.Name & ebDot & ebLogNameRT, SharedOutcomes.RT
	c.SetAttrib SharedOutcomes.Name & ebDot & ebLogNameRESP, SharedOutcomes.RESP
	c.SetAttrib SharedOutcomes.Name & ebDot & ebLogNameCRESP, SharedOutcomes.CRESP
	c.SetAttrib SharedOutcomes.Name & ebDot & ebLogNameOnsetToOnsetTime, SharedOutcomes.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub









'--------------------------------------------------------------------------
' InitDevices
'
'--------------------------------------------------------------------------
Sub InitDevices(c As Context)


	Set Display = New DisplayDevice
	Display.Name = ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y

	Dim DisplayDisplayDeviceInfo As DisplayDeviceInfo
	DisplayDisplayDeviceInfo.XRes = 1920
	DisplayDisplayDeviceInfo.YRes = 1080
	DisplayDisplayDeviceInfo.ColorDepth = 32
	DisplayDisplayDeviceInfo.DisplayIndex = 1
	DisplayDisplayDeviceInfo.UseDesktopSettings = False
	DisplayDisplayDeviceInfo.DefaultColor = Color.Black
	DisplayDisplayDeviceInfo.RefreshRateRequested = 0
	DisplayDisplayDeviceInfo.NumPages = 0

	'Load values from context if they exist
	If c.AttribExists(Display.Name & ebDot & ebUCase_X & ebUCase_R & ebLCase_e & ebLCase_s) Then DisplayDisplayDeviceInfo.XRes = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_X & ebUCase_R & ebLCase_e & ebLCase_s))
	If c.AttribExists(Display.Name & ebDot & ebUCase_Y & ebUCase_R & ebLCase_e & ebLCase_s) Then DisplayDisplayDeviceInfo.YRes = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_Y & ebUCase_R & ebLCase_e & ebLCase_s))
	If c.AttribExists(Display.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r & ebUCase_D & ebLCase_e & ebLCase_p & ebLCase_t & ebLCase_h) Then DisplayDisplayDeviceInfo.ColorDepth = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r & ebUCase_D & ebLCase_e & ebLCase_p & ebLCase_t & ebLCase_h))
	If c.AttribExists(Display.Name & ebDot & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_I & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_x) Then DisplayDisplayDeviceInfo.DisplayIndex = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_I & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_x))
	If c.AttribExists(Display.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r) Then DisplayDisplayDeviceInfo.DefaultColor = CColor(c.GetAttrib(Display.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r))
	If c.AttribExists(Display.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_d) Then DisplayDisplayDeviceInfo.RefreshRateRequested = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_d))
	If c.AttribExists(Display.Name & ebDot & ebUCase_N & ebLCase_u & ebLCase_m & ebUCase_P & ebLCase_a & ebLCase_g & ebLCase_e & ebLCase_s) Then DisplayDisplayDeviceInfo.NumPages = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_N & ebLCase_u & ebLCase_m & ebUCase_P & ebLCase_a & ebLCase_g & ebLCase_e & ebLCase_s))
	If c.AttribExists(Display.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_s & ebLCase_k & ebLCase_t & ebLCase_o & ebLCase_p & ebUCase_S & ebLCase_e & ebLCase_t & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s) Then DisplayDisplayDeviceInfo.UseDesktopSettings = CLogical(c.GetAttrib(Display.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_s & ebLCase_k & ebLCase_t & ebLCase_o & ebLCase_p & ebUCase_S & ebLCase_e & ebLCase_t & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s))

	'Open the device, unless the context values indicate otherwise
	Dim DisplayOpen As Boolean
	DisplayOpen = True
	If c.AttribExists(Display.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n) Then DisplayOpen = CLogical(c.GetAttrib(Display.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n))
	If DisplayOpen = True Then
		Display.Open DisplayDisplayDeviceInfo
		Display.RefreshAlignment = ebDigit_2 & ebDigit_5 & ebPercent
		If c.AttribExists(Display.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_A & ebLCase_l & ebLCase_i & ebLCase_g & ebLCase_n & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t) Then Display.RefreshAlignment = c.GetAttrib(Display.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_A & ebLCase_l & ebLCase_i & ebLCase_g & ebLCase_n & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t)
	#If RUNTIME_VERSION_PERSIST >= 201 Then
		Display.RTAdjustment = 0
		If c.AttribExists(Display.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t) Then Display.RTAdjustment = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t))
	#End If
End If

	'Enable flipping, if requested
	If c.AttribExists(Display.Name & ebDot & ebUCase_F & ebLCase_l & ebLCase_i & ebLCase_p & ebLCase_p & ebLCase_i & ebLCase_n & ebLCase_g & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d) Then
		Display.FlippingEnabled = CLogical(c.GetAttrib(Display.Name & ebDot & ebUCase_F & ebLCase_l & ebLCase_i & ebLCase_p & ebLCase_p & ebLCase_i & ebLCase_n & ebLCase_g & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d))
	Else
		Display.FlippingEnabled = True
	End If

	Set Keyboard = New KeyboardDevice
	Keyboard.Name = ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_b & ebLCase_o & ebLCase_a & ebLCase_r & ebLCase_d


	Dim KeyboardKeyboardDeviceInfo as KeyboardDeviceInfo
	KeyboardKeyboardDeviceInfo.CollectionMode = ebPressesOnly
	KeyboardKeyboardDeviceInfo.CapsLock = ebCapsLockOff
	KeyboardKeyboardDeviceInfo.NumLock = ebNumLockOn
	'Load values from context if they exist
	If c.AttribExists(Keyboard.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_l & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e) Then KeyboardKeyboardDeviceInfo.CollectionMode = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_l & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e))
	If c.AttribExists(Keyboard.Name & ebDot & ebUCase_C & ebLCase_a & ebLCase_p & ebLCase_s & ebUCase_L & ebLCase_o & ebLCase_c & ebLCase_k) Then KeyboardKeyboardDeviceInfo.CapsLock = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_C & ebLCase_a & ebLCase_p & ebLCase_s & ebUCase_L & ebLCase_o & ebLCase_c & ebLCase_k))
	If c.AttribExists(Keyboard.Name & ebDot & ebUCase_N & ebLCase_u & ebLCase_m & ebUCase_L & ebLCase_o & ebLCase_c & ebLCase_k) Then KeyboardKeyboardDeviceInfo.NumLock = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_N & ebLCase_u & ebLCase_m & ebUCase_L & ebLCase_o & ebLCase_c & ebLCase_k))
	If c.AttribExists(Keyboard.Name & ebDot & ebUCase_E & ebLCase_m & ebLCase_u & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e) Then KeyboardKeyboardDeviceInfo.EmulateDeviceName = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_E & ebLCase_m & ebLCase_u & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e)

	'Open the device, unless the context values indicate otherwise
	Dim KeyboardOpen As Boolean
	KeyboardOpen = True
	If c.AttribExists(Keyboard.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n) Then KeyboardOpen = CLogical(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n))
	If KeyboardOpen = True Then
		Keyboard.Open KeyboardKeyboardDeviceInfo
#If RUNTIME_VERSION_PERSIST >= 201 Then
		Keyboard.RTAdjustment = 0
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t) Then Keyboard.RTAdjustment = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t))
	#End If

		Keyboard.AutoResponseEnabled = True
		Keyboard.AutoResponseTimeLimitLowerBound = ebDigit_2 & ebDigit_5 & ebPercent
		Keyboard.AutoResponseTimeLimitUpperBound = ebDigit_7 & ebDigit_5 & ebPercent
		Keyboard.AutoResponseTimeLimitWhenInfinite = 1000
		Keyboard.AutoResponseCorrectProbability = ebDigit_8 & ebDigit_0 & ebPercent
		Keyboard.AutoResponseAllowableOverride = ebEmptyText
		Keyboard.AutoResponseMaxCountLowerBound = ebDigit_2 & ebDigit_5 & ebPercent
		Keyboard.AutoResponseMaxCountUpperBound = ebDigit_7 & ebDigit_5 & ebPercent
		Keyboard.AutoResponseDelayBetweenResponses = 30
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d) Then Keyboard.AutoResponseEnabled = CLogical(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d))
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_L & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d) Then Keyboard.AutoResponseTimeLimitLowerBound = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_L & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_U & ebLCase_p & ebLCase_p & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d) Then Keyboard.AutoResponseTimeLimitUpperBound = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_U & ebLCase_p & ebLCase_p & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_W & ebLCase_h & ebLCase_e & ebLCase_n & ebUCase_I & ebLCase_n & ebLCase_f & ebLCase_i & ebLCase_n & ebLCase_i & ebLCase_t & ebLCase_e) Then Keyboard.AutoResponseTimeLimitWhenInfinite = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_W & ebLCase_h & ebLCase_e & ebLCase_n & ebUCase_I & ebLCase_n & ebLCase_f & ebLCase_i & ebLCase_n & ebLCase_i & ebLCase_t & ebLCase_e))
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_C & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_b & ebLCase_a & ebLCase_b & ebLCase_i & ebLCase_l & ebLCase_i & ebLCase_t & ebLCase_y) Then Keyboard.AutoResponseCorrectProbability = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_C & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_b & ebLCase_a & ebLCase_b & ebLCase_i & ebLCase_l & ebLCase_i & ebLCase_t & ebLCase_y)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_A & ebLCase_l & ebLCase_l & ebLCase_o & ebLCase_w & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebUCase_O & ebLCase_v & ebLCase_e & ebLCase_r & ebLCase_r & ebLCase_i & ebLCase_d & ebLCase_e) Then Keyboard.AutoResponseAllowableOverride = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_A & ebLCase_l & ebLCase_l & ebLCase_o & ebLCase_w & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebUCase_O & ebLCase_v & ebLCase_e & ebLCase_r & ebLCase_r & ebLCase_i & ebLCase_d & ebLCase_e)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_C & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebUCase_L & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d) Then Keyboard.AutoResponseMaxCountLowerBound = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_C & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebUCase_L & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_C & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebUCase_U & ebLCase_p & ebLCase_p & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d) Then Keyboard.AutoResponseMaxCountUpperBound = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_C & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebUCase_U & ebLCase_p & ebLCase_p & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_B & ebLCase_e & ebLCase_t & ebLCase_w & ebLCase_e & ebLCase_e & ebLCase_n & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebLCase_s) Then Keyboard.AutoResponseDelayBetweenResponses = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_B & ebLCase_e & ebLCase_t & ebLCase_w & ebLCase_e & ebLCase_e & ebLCase_n & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebLCase_s))
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_S & ebLCase_y & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_m & ebUCase_A & ebLCase_b & ebLCase_o & ebLCase_r & ebLCase_t & ebUCase_W & ebLCase_a & ebLCase_t & ebLCase_c & ebLCase_h & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Keyboard.SystemAbortWatchSequence = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_S & ebLCase_y & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_m & ebUCase_A & ebLCase_b & ebLCase_o & ebLCase_r & ebLCase_t & ebUCase_W & ebLCase_a & ebLCase_t & ebLCase_c & ebLCase_h & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_a & ebLCase_l & ebUCase_E & ebLCase_x & ebLCase_i & ebLCase_t & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Keyboard.ConditionalExitSequence = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_a & ebLCase_l & ebUCase_E & ebLCase_x & ebLCase_i & ebLCase_t & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_r & ebLCase_e & ebLCase_a & ebLCase_k & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Keyboard.UserBreakSequence = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_r & ebLCase_e & ebLCase_a & ebLCase_k & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)

	End If

	Set Mouse = New MouseDevice
	Mouse.Name = ebUCase_M & ebLCase_o & ebLCase_u & ebLCase_s & ebLCase_e


	Dim MouseMouseDeviceInfo as MouseDeviceInfo
	MouseMouseDeviceInfo.OpenMode = ebMouseOpenModeDirect
	MouseMouseDeviceInfo.CollectionMode = ebPressesOnly
	MouseMouseDeviceInfo.ShowCursor = False
	'Load values from context if they exist
	If c.AttribExists(Mouse.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e) Then MouseMouseDeviceInfo.OpenMode = CLng(c.GetAttrib(Mouse.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e))
	If c.AttribExists(Mouse.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_l & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e) Then MouseMouseDeviceInfo.CollectionMode = CLng(c.GetAttrib(Mouse.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_l & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e))
	If c.AttribExists(Mouse.Name & ebDot & ebUCase_S & ebLCase_h & ebLCase_o & ebLCase_w & ebUCase_C & ebLCase_u & ebLCase_r & ebLCase_s & ebLCase_o & ebLCase_r) Then MouseMouseDeviceInfo.ShowCursor = CLng(c.GetAttrib(Mouse.Name & ebDot & ebUCase_S & ebLCase_h & ebLCase_o & ebLCase_w & ebUCase_C & ebLCase_u & ebLCase_r & ebLCase_s & ebLCase_o & ebLCase_r))
	If c.AttribExists(Mouse.Name & ebDot & ebUCase_E & ebLCase_m & ebLCase_u & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e) Then MouseMouseDeviceInfo.EmulateDeviceName = c.GetAttrib(Mouse.Name & ebDot & ebUCase_E & ebLCase_m & ebLCase_u & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e)

	'Open the device, unless the context values indicate otherwise
	Dim MouseOpen As Boolean
	MouseOpen = True
	If c.AttribExists(Mouse.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n) Then MouseOpen = CLogical(c.GetAttrib(Mouse.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n))
	If MouseOpen = True Then
		Mouse.Open MouseMouseDeviceInfo
		If c.AttribExists(Mouse.Name & ebDot & ebUCase_S & ebLCase_y & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_m & ebUCase_A & ebLCase_b & ebLCase_o & ebLCase_r & ebLCase_t & ebUCase_W & ebLCase_a & ebLCase_t & ebLCase_c & ebLCase_h & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Mouse.SystemAbortWatchSequence = c.GetAttrib(Mouse.Name & ebDot & ebUCase_S & ebLCase_y & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_m & ebUCase_A & ebLCase_b & ebLCase_o & ebLCase_r & ebLCase_t & ebUCase_W & ebLCase_a & ebLCase_t & ebLCase_c & ebLCase_h & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
		If c.AttribExists(Mouse.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_a & ebLCase_l & ebUCase_E & ebLCase_x & ebLCase_i & ebLCase_t & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Mouse.ConditionalExitSequence = c.GetAttrib(Mouse.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_a & ebLCase_l & ebUCase_E & ebLCase_x & ebLCase_i & ebLCase_t & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
		If c.AttribExists(Mouse.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_r & ebLCase_e & ebLCase_a & ebLCase_k & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Mouse.UserBreakSequence = c.GetAttrib(Mouse.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_r & ebLCase_e & ebLCase_a & ebLCase_k & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
	#If RUNTIME_VERSION_PERSIST >= 201 Then
		Mouse.RTAdjustment = 0
		If c.AttribExists(Mouse.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t) Then Mouse.RTAdjustment = CLng(c.GetAttrib(Mouse.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t))
	#End If

	End If

	Set Sound = New SoundDevice
	Sound.Name = ebUCase_S & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d

	Dim SoundSoundDeviceInfo As SoundDeviceInfo
	SoundSoundDeviceInfo.API = ebSoundApiDirectSound
	SoundSoundDeviceInfo.DeviceIndex = 1
	SoundSoundDeviceInfo.Channels = 0
	SoundSoundDeviceInfo.SamplesPerSecond = 0
	SoundSoundDeviceInfo.BitsPerSample = 0
	SoundSoundDeviceInfo.DeviceReserved1 = 0
	SoundSoundDeviceInfo.DeviceReserved2 = 0
	SoundSoundDeviceInfo.DeviceReserved3 = 0
	SoundSoundDeviceInfo.DeviceReserved4 = 0
	SoundSoundDeviceInfo.DeviceReservedA = ebEmptyText
	SoundSoundDeviceInfo.DeviceReservedB = ebEmptyText
	SoundSoundDeviceInfo.DeviceReservedC = ebEmptyText
	SoundSoundDeviceInfo.DeviceReservedD = ebEmptyText

	'Load values from context if they exist
	If c.AttribExists(Sound.Name & ebDot & ebUCase_A & ebUCase_P & ebUCase_I) Then SoundSoundDeviceInfo.API = c.GetAttrib(Sound.Name & ebDot & ebUCase_A & ebUCase_P & ebUCase_I)
	If c.AttribExists(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_I & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_x) Then SoundSoundDeviceInfo.DeviceIndex = CLng(c.GetAttrib(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_I & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_x))
	If c.AttribExists(Sound.Name & ebDot & ebUCase_C & ebLCase_h & ebLCase_a & ebLCase_n & ebLCase_n & ebLCase_e & ebLCase_l & ebLCase_s) Then SoundSoundDeviceInfo.Channels = CLng(c.GetAttrib(Sound.Name & ebDot & ebUCase_C & ebLCase_h & ebLCase_a & ebLCase_n & ebLCase_n & ebLCase_e & ebLCase_l & ebLCase_s))
	If c.AttribExists(Sound.Name & ebDot & ebUCase_S & ebLCase_a & ebLCase_m & ebLCase_p & ebLCase_l & ebLCase_e & ebLCase_s & ebUCase_P & ebLCase_e & ebLCase_r & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d) Then SoundSoundDeviceInfo.SamplesPerSecond = CLng(c.GetAttrib(Sound.Name & ebDot & ebUCase_S & ebLCase_a & ebLCase_m & ebLCase_p & ebLCase_l & ebLCase_e & ebLCase_s & ebUCase_P & ebLCase_e & ebLCase_r & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d))
	If c.AttribExists(Sound.Name & ebDot & ebUCase_B & ebLCase_i & ebLCase_t & ebLCase_s & ebUCase_P & ebLCase_e & ebLCase_r & ebUCase_S & ebLCase_a & ebLCase_m & ebLCase_p & ebLCase_l & ebLCase_e) Then SoundSoundDeviceInfo.BitsPerSample = CLng(c.GetAttrib(Sound.Name & ebDot & ebUCase_B & ebLCase_i & ebLCase_t & ebLCase_s & ebUCase_P & ebLCase_e & ebLCase_r & ebUCase_S & ebLCase_a & ebLCase_m & ebLCase_p & ebLCase_l & ebLCase_e))
	If c.AttribExists(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebDigit_1) Then SoundSoundDeviceInfo.DeviceReserved1 = CLng(c.GetAttrib(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebDigit_1))
	If c.AttribExists(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebDigit_2) Then SoundSoundDeviceInfo.DeviceReserved2 = CLng(c.GetAttrib(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebDigit_2))
	If c.AttribExists(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebDigit_3) Then SoundSoundDeviceInfo.DeviceReserved3 = CLng(c.GetAttrib(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebDigit_3))
	If c.AttribExists(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebDigit_4) Then SoundSoundDeviceInfo.DeviceReserved4 = CLng(c.GetAttrib(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebDigit_4))
	If c.AttribExists(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_A) Then SoundSoundDeviceInfo.DeviceReservedA = c.GetAttrib(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_A)
	If c.AttribExists(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_B) Then SoundSoundDeviceInfo.DeviceReservedB = c.GetAttrib(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_B)
	If c.AttribExists(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_C) Then SoundSoundDeviceInfo.DeviceReservedC = c.GetAttrib(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_C)
	If c.AttribExists(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_D) Then SoundSoundDeviceInfo.DeviceReservedD = c.GetAttrib(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_D)

	'Open the device, unless the context values indicate otherwise
	Dim SoundOpen As Boolean
	SoundOpen = True
	If c.AttribExists(Sound.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n) Then SoundOpen = CLogical(c.GetAttrib(Sound.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n))
	If SoundOpen = True Then
		Sound.Open SoundSoundDeviceInfo
#If RUNTIME_VERSION_PERSIST >= 201 Then
		Sound.RTAdjustment = 0
		If c.AttribExists(Sound.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t) Then Sound.RTAdjustment = CLng(c.GetAttrib(Sound.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t))
	#End If
	End If

	Set ParallelPort = New ParallelPortDevice
	ParallelPort.Name = "ParallelPort"
	Dim ParallelPortParallelPortDeviceInfo As ParallelPortDeviceInfo
	ParallelPortParallelPortDeviceInfo.CollectionMode = ebPressesOnly
	ParallelPortParallelPortDeviceInfo.LPT = 3
	ParallelPortParallelPortDeviceInfo.Invert = CLogical("No")
	ParallelPortParallelPortDeviceInfo.Mask = -1
	ParallelPortParallelPortDeviceInfo.DataPort = 0
	ParallelPortParallelPortDeviceInfo.Debounce = 0
	'Load values from context if they exist
	If c.AttribExists(ParallelPort.Name & ".CollectionMode") Then ParallelPortParallelPortDeviceInfo.CollectionMode = c.GetAttrib(ParallelPort.Name & ".CollectionMode")
	If c.AttribExists(ParallelPort.Name & ".LPT") Then ParallelPortParallelPortDeviceInfo.LPT = CLng(c.GetAttrib(ParallelPort.Name & ".LPT"))
	If c.AttribExists(ParallelPort.Name & ".Invert") Then ParallelPortParallelPortDeviceInfo.Invert = c.GetAttrib(ParallelPort.Name & ".Invert")
	If c.AttribExists(ParallelPort.Name & ".Mask") Then ParallelPortParallelPortDeviceInfo.Mask = c.GetAttrib(ParallelPort.Name & ".Mask")
	If c.AttribExists(ParallelPort.Name & ".DataPort") Then ParallelPortParallelPortDeviceInfo.DataPort = CLng(c.GetAttrib(ParallelPort.Name & ".DataPort"))
	If c.AttribExists(ParallelPort.Name & ".Debounce") Then ParallelPortParallelPortDeviceInfo.Debounce = CLng(c.GetAttrib(ParallelPort.Name & ".Debounce"))
	If c.AttribExists(ParallelPort.Name & ".EmulateDeviceName") Then ParallelPortParallelPortDeviceInfo.EmulateDeviceName = c.GetAttrib(ParallelPort.Name & ".EmulateDeviceName")

	'Open the device, unless the context values indicate otherwise
	Dim ParallelPortOpen As Boolean
	ParallelPortOpen = True
	If c.AttribExists(ParallelPort.Name & ".Open") Then ParallelPortOpen = CLogical(c.GetAttrib(ParallelPort.Name & ".Open"))
	If ParallelPortOpen = True Then
		ParallelPort.Open ParallelPortParallelPortDeviceInfo

		'Set parallel port IO mode
		ParallelPort.ConfigurePortForOutput
#If RUNTIME_VERSION_PERSIST >= 201 Then
		ParallelPort.RTAdjustment = 0
		If c.AttribExists(ParallelPort.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t) Then ParallelPort.RTAdjustment = CLng(c.GetAttrib(ParallelPort.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t))
	#End If
	End If

	'Init All Devices
	Rte.DeviceManager.Init

	' Log DisplayDevice(s) Refresh Rates
	If DisplayOpen = True Then
		c.SetAttrib Display.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e, Format$(Display.CalculatedRefreshRate, ebDigit_0 & ebDot & ebDigit_0 & ebDigit_0 & ebDigit_0)

		'Ensure that the refresh rate is acceptable
		If CLng(Display.CalculatedRefreshRate) = 0 Then
			'WARNING: RefreshRate of 0 (Zero) Detected.  Experiment will assume 60hz to continue. Data collection should NOT be used for time critical analysis.  Please ensure your display adapter is configured with the most recent and device specific driver.\n(Standard Display Adapter under Windows Vista or later is not compatible)
			Dim strDisplayError As String
			strDisplayError = ebUCase_W & ebUCase_A & ebUCase_R & ebUCase_N & ebUCase_I & ebUCase_N & ebUCase_G & ebColon & ebSpace & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e & ebSpace & ebLCase_o & ebLCase_f & ebSpace & ebDigit_0 & ebSpace & ebParenOpen & ebUCase_Z & ebLCase_e & ebLCase_r & ebLCase_o & ebParenClose & ebSpace & ebUCase_D & ebLCase_e & ebLCase_t & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_e & ebLCase_d & ebDot & ebSpace & ebSpace & ebUCase_E & ebLCase_x & ebLCase_p & ebLCase_e & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t & ebSpace & ebLCase_w & ebLCase_i & ebLCase_l & ebLCase_l & ebSpace & ebLCase_a & ebLCase_s & ebLCase_s & ebLCase_u & ebLCase_m & ebLCase_e & ebSpace & ebDigit_6 & ebDigit_0 & ebLCase_h & ebLCase_z & ebSpace & ebLCase_t & ebLCase_o & ebSpace & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_u & ebLCase_e & ebDot & ebSpace & ebUCase_D & ebLCase_a & ebLCase_t & ebLCase_a & ebSpace & ebLCase_c & ebLCase_o & ebLCase_l & ebLCase_l & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebSpace & ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_u & ebLCase_l & ebLCase_d & ebSpace & ebUCase_N & ebUCase_O & ebUCase_T & ebSpace & ebLCase_b & ebLCase_e & ebSpace & ebLCase_u & ebLCase_s & ebLCase_e & ebLCase_d & ebSpace & ebLCase_f & ebLCase_o & ebLCase_r & ebSpace & ebLCase_t & ebLCase_i & ebLCase_m & ebLCase_e & ebSpace & ebLCase_c & ebLCase_r & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_c & ebLCase_a & ebLCase_l & ebSpace & ebLCase_a & ebLCase_n & ebLCase_a & ebLCase_l & ebLCase_y & ebLCase_s & ebLCase_i & ebLCase_s & ebDot & ebSpace & ebSpace & ebUCase_P & ebLCase_l & ebLCase_e & ebLCase_a & ebLCase_s & ebLCase_e & ebSpace & ebLCase_e & ebLCase_n & ebLCase_s & ebLCase_u & ebLCase_r & ebLCase_e & ebSpace & ebLCase_y & ebLCase_o & ebLCase_u & ebLCase_r & ebSpace & ebLCase_d & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebSpace & ebLCase_a & ebLCase_d & ebLCase_a & ebLCase_p & ebLCase_t & ebLCase_e & ebLCase_r & ebSpace & ebLCase_i & ebLCase_s & ebSpace & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_f & ebLCase_i & ebLCase_g & ebLCase_u & ebLCase_r & ebLCase_e & ebLCase_d & ebSpace & ebLCase_w & ebLCase_i & ebLCase_t & ebLCase_h & ebSpace & ebLCase_t & ebLCase_h & ebLCase_e & ebSpace & ebLCase_m & ebLCase_o & ebLCase_s & ebLCase_t & ebSpace & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_e & ebLCase_n & ebLCase_t & ebSpace & ebLCase_a & ebLCase_n & ebLCase_d & ebSpace & ebLCase_d & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebSpace & ebLCase_s & ebLCase_p & ebLCase_e & ebLCase_c & ebLCase_i & ebLCase_f & ebLCase_i & ebLCase_c & ebSpace & ebLCase_d & ebLCase_r & ebLCase_i & ebLCase_v & ebLCase_e & ebLCase_r & ebDot & ebLf & ebParenOpen & ebUCase_S & ebLCase_t & ebLCase_a & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_d & ebSpace & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebSpace & ebUCase_A & ebLCase_d & ebLCase_a & ebLCase_p & ebLCase_t & ebLCase_e & ebLCase_r & ebSpace & ebLCase_u & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_r & ebSpace & ebUCase_W & ebLCase_i & ebLCase_n & ebLCase_d & ebLCase_o & ebLCase_w & ebLCase_s & ebSpace & ebUCase_V & ebLCase_i & ebLCase_s & ebLCase_t & ebLCase_a & ebSpace & ebLCase_o & ebLCase_r & ebSpace & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebLCase_r & ebSpace & ebLCase_i & ebLCase_s & ebSpace & ebLCase_n & ebLCase_o & ebLCase_t & ebSpace & ebLCase_c & ebLCase_o & ebLCase_m & ebLCase_p & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_b & ebLCase_l & ebLCase_e & ebParenClose
			Debug.Print strDisplayError
			c.SetAttrib ebUCase_A & ebUCase_W & ebLCase_a & ebLCase_r & ebLCase_n & ebLCase_i & ebLCase_n & ebLCase_g & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e, strDisplayError
		End If

		'Determine RefreshRate range
		Dim dblDisplayMinRefreshRate As Double
		Dim dblDisplayMaxRefreshRate As Double
		dblDisplayMinRefreshRate = 39
		dblDisplayMaxRefreshRate = 201
		If c.AttribExists(Display.Name & ebDot & ebUCase_M & ebLCase_i & ebLCase_n & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e) Then dblDisplayMinRefreshRate = CDbl(c.GetAttrib(Display.Name & ebDot & ebUCase_M & ebLCase_i & ebLCase_n & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e))
		If c.AttribExists(Display.Name & ebDot & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e) Then dblDisplayMaxRefreshRate = CDbl(c.GetAttrib(Display.Name & ebDot & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e))

		'Ensure that the refresh rate is within range
		If Display.CalculatedRefreshRate < dblDisplayMinRefreshRate Or Display.CalculatedRefreshRate > dblDisplayMaxRefreshRate Then
			'Unable to obtain a valid refresh rate.\n\nPlease ensure your display adapter is configured with the most recent and device specific driver.\n(Standard Display Adapter under Windows Vista is not compatible)
			Rte.AbortExperiment -999, ebUCase_U & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebSpace & ebLCase_t & ebLCase_o & ebSpace & ebLCase_o & ebLCase_b & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n & ebSpace & ebLCase_a & ebSpace & ebLCase_v & ebLCase_a & ebLCase_l & ebLCase_i & ebLCase_d & ebSpace & ebLCase_r & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebSpace & ebLCase_r & ebLCase_a & ebLCase_t & ebLCase_e & ebDot & ebLf & ebLf & ebUCase_P & ebLCase_l & ebLCase_e & ebLCase_a & ebLCase_s & ebLCase_e & ebSpace & ebLCase_e & ebLCase_n & ebLCase_s & ebLCase_u & ebLCase_r & ebLCase_e & ebSpace & ebLCase_y & ebLCase_o & ebLCase_u & ebLCase_r & ebSpace & ebLCase_d & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebSpace & ebLCase_a & ebLCase_d & ebLCase_a & ebLCase_p & ebLCase_t & ebLCase_e & ebLCase_r & ebSpace & ebLCase_i & ebLCase_s & ebSpace & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_f & ebLCase_i & ebLCase_g & ebLCase_u & ebLCase_r & ebLCase_e & ebLCase_d & ebSpace & ebLCase_w & ebLCase_i & ebLCase_t & ebLCase_h & ebSpace & ebLCase_t & ebLCase_h & ebLCase_e & ebSpace & ebLCase_m & ebLCase_o & ebLCase_s & ebLCase_t & ebSpace & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_e & ebLCase_n & ebLCase_t & ebSpace & ebLCase_a & ebLCase_n & ebLCase_d & ebSpace & ebLCase_d & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebSpace & ebLCase_s & ebLCase_p & ebLCase_e & ebLCase_c & ebLCase_i & ebLCase_f & ebLCase_i & ebLCase_c & ebSpace & ebLCase_d & ebLCase_r & ebLCase_i & ebLCase_v & ebLCase_e & ebLCase_r & ebDot & ebLf & ebParenOpen & ebUCase_S & ebLCase_t & ebLCase_a & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_d & ebSpace & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebSpace & ebUCase_A & ebLCase_d & ebLCase_a & ebLCase_p & ebLCase_t & ebLCase_e & ebLCase_r & ebSpace & ebLCase_u & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_r & ebSpace & ebUCase_W & ebLCase_i & ebLCase_n & ebLCase_d & ebLCase_o & ebLCase_w & ebLCase_s & ebSpace & ebUCase_V & ebLCase_i & ebLCase_s & ebLCase_t & ebLCase_a & ebSpace & ebLCase_i & ebLCase_s & ebSpace & ebLCase_n & ebLCase_o & ebLCase_t & ebSpace & ebLCase_c & ebLCase_o & ebLCase_m & ebLCase_p & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_b & ebLCase_l & ebLCase_e & ebParenClose
		End If
	End If

End Sub



'--------------------------------------------------------------------------
' InitObjects
'
'--------------------------------------------------------------------------
Sub InitObjects(c As Context)

	Set SessionProc = New Procedure
	SessionProc.Name = ebUCase_S & ebLCase_e & ebLCase_s & ebLCase_s & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c
	'{1E5FF857-9066-44F0-A9B6-285D5B687081}
	SessionProc.Guid = CGuid(&H1E5FF857, &H9066, &H44F0, &HA9B6, &H285D5B68, &H7081)
	SessionProc.Tag = ebEmptyText

	SessionProc.LoadProperties
	SessionProc.Subroutine = ebUCase_S & ebLCase_e & ebLCase_s & ebLCase_s & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set SessionProc_theCollection = New RteCollection

	Set List1 = New List
	List1.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_1
	'{74198919-B126-4EDE-903C-66B69E0F5CC9}
	List1.Guid = CGuid(&H74198919, &HB126, &H4EDE, &H903C, &H66B69E0F, &H5CC9)
	List1.Tag = ebEmptyText

	'Initialization for List1

	Set List1.Order = New SequentialOrder
	Set List1.Deletion = NoDeletion
	List1.ResetEveryRun = False

	List1.LoadProperties

	Set List1.TerminateCondition = Cycles(1)
	Set List1.ResetCondition = Samples(5)
	List1.Reset

	Set Instructions = New Procedure
	Instructions.Name = ebUCase_I & ebLCase_n & ebLCase_s & ebLCase_t & ebLCase_r & ebLCase_u & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_s
	'{89DC75A7-40A9-48C3-A8E4-AE1BBC6AEB52}
	Instructions.Guid = CGuid(&H89DC75A7, &H40A9, &H48C3, &HA8E4, &HAE1BBC6A, &HEB52)
	Instructions.Tag = ebEmptyText

	Instructions.LoadProperties
	Instructions.Subroutine = ebUCase_I & ebLCase_n & ebLCase_s & ebLCase_t & ebLCase_r & ebLCase_u & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_s & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Instructions_theCollection = New RteCollection

	Set Ratings = New Procedure
	Ratings.Name = ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s
	'{53629937-776C-4955-8EDC-7C9DAD53C87F}
	Ratings.Guid = CGuid(&H53629937, &H776C, &H4955, &H8EDC, &H7C9DAD53, &HC87F)
	Ratings.Tag = ebEmptyText

	Ratings.LoadProperties
	Ratings.Subroutine = ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Ratings_theCollection = New RteCollection

	Set SelfTask = New Procedure
	SelfTask.Name = ebUCase_S & ebLCase_e & ebLCase_l & ebLCase_f & ebUCase_T & ebLCase_a & ebLCase_s & ebLCase_k
	'{15185BE7-060D-4C8F-BBA4-363807129D09}
	SelfTask.Guid = CGuid(&H15185BE7, &H060D, &H4C8F, &HBBA4, &H36380712, &H9D09)
	SelfTask.Tag = ebEmptyText

	SelfTask.LoadProperties
	SelfTask.Subroutine = ebUCase_S & ebLCase_e & ebLCase_l & ebLCase_f & ebUCase_T & ebLCase_a & ebLCase_s & ebLCase_k & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set SelfTask_theCollection = New RteCollection

	Set OtherTask = New Procedure
	OtherTask.Name = ebUCase_O & ebLCase_t & ebLCase_h & ebLCase_e & ebLCase_r & ebUCase_T & ebLCase_a & ebLCase_s & ebLCase_k
	'{757F58BF-5A88-46A9-A17A-6FCC36EF6E2A}
	OtherTask.Guid = CGuid(&H757F58BF, &H5A88, &H46A9, &HA17A, &H6FCC36EF, &H6E2A)
	OtherTask.Tag = ebEmptyText

	OtherTask.LoadProperties
	OtherTask.Subroutine = ebUCase_O & ebLCase_t & ebLCase_h & ebLCase_e & ebLCase_r & ebUCase_T & ebLCase_a & ebLCase_s & ebLCase_k & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set OtherTask_theCollection = New RteCollection

	Set BothTask = New Procedure
	BothTask.Name = ebUCase_B & ebLCase_o & ebLCase_t & ebLCase_h & ebUCase_T & ebLCase_a & ebLCase_s & ebLCase_k
	'{2D3E5AAE-B3C4-4E71-BE83-8BA46954D917}
	BothTask.Guid = CGuid(&H2D3E5AAE, &HB3C4, &H4E71, &HBE83, &H8BA46954, &HD917)
	BothTask.Tag = ebEmptyText

	BothTask.LoadProperties
	BothTask.Subroutine = ebUCase_B & ebLCase_o & ebLCase_t & ebLCase_h & ebUCase_T & ebLCase_a & ebLCase_s & ebLCase_k & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set BothTask_theCollection = New RteCollection

	Set ITI = New TextDisplay
	ITI.Name = ebUCase_I & ebUCase_T & ebUCase_I
	'{3BF13568-B9B7-45E2-B3F6-1DBBF1D729D8}
	ITI.Guid = CGuid(&H3BF13568, &HB9B7, &H45E2, &HB3F6, &H1DBBF1D7, &H29D8)
	ITI.Tag = ebEmptyText

	ITI.LoadProperties

	Set Options = New Slide
	Options.Name = ebUCase_O & ebLCase_p & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_s
	'{F5086BC4-CEDB-4E2D-B499-7E753251992F}
	Options.Guid = CGuid(&HF5086BC4, &HCEDB, &H4E2D, &HB499, &H7E753251, &H992F)
	Options.Tag = ebEmptyText

	Options.LoadProperties

	Set ISI = New TextDisplay
	ISI.Name = ebUCase_I & ebUCase_S & ebUCase_I
	'{54B4FB61-5C81-4EE2-9ACB-0E0E8E4EF290}
	ISI.Guid = CGuid(&H54B4FB61, &H5C81, &H4EE2, &H9ACB, &H0E0E8E4E, &HF290)
	ISI.Tag = ebEmptyText

	ISI.LoadProperties

	Set Response = New Slide
	Response.Name = ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e
	'{F0C77574-5E36-48CB-AEF2-55762F92A822}
	Response.Guid = CGuid(&HF0C77574, &H5E36, &H48CB, &HAEF2, &H55762F92, &HA822)
	Response.Tag = ebEmptyText

	Set ResponseEchoClients = New EchoClientCollection

	Response.LoadProperties

	Set BothFB = New FeedbackDisplay
	BothFB.Name = ebUCase_B & ebLCase_o & ebLCase_t & ebLCase_h & ebUCase_F & ebUCase_B
	'{4510BA59-611D-4F17-B888-5F500C47DDE1}
	BothFB.Guid = CGuid(&H4510BA59, &H611D, &H4F17, &HB888, &H5F500C47, &HDDE1)
	BothFB.Tag = ebEmptyText

	BothFB.LoadProperties

	Set LASelfMixed = New Procedure
	LASelfMixed.Name = ebUCase_L & ebUCase_A & ebUCase_S & ebLCase_e & ebLCase_l & ebLCase_f & ebUCase_M & ebLCase_i & ebLCase_x & ebLCase_e & ebLCase_d
	'{B496FCDB-F760-4635-AA5D-28EB5F6AE580}
	LASelfMixed.Guid = CGuid(&HB496FCDB, &HF760, &H4635, &HAA5D, &H28EB5F6A, &HE580)
	LASelfMixed.Tag = ebEmptyText

	LASelfMixed.LoadProperties
	LASelfMixed.Subroutine = ebUCase_L & ebUCase_A & ebUCase_S & ebLCase_e & ebLCase_l & ebLCase_f & ebUCase_M & ebLCase_i & ebLCase_x & ebLCase_e & ebLCase_d & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set LASelfMixed_theCollection = New RteCollection

	Set LASelfGain = New Procedure
	LASelfGain.Name = ebUCase_L & ebUCase_A & ebUCase_S & ebLCase_e & ebLCase_l & ebLCase_f & ebUCase_G & ebLCase_a & ebLCase_i & ebLCase_n
	'{69D8FD41-E493-4CDA-8FA9-FB0B527FB22D}
	LASelfGain.Guid = CGuid(&H69D8FD41, &HE493, &H4CDA, &H8FA9, &HFB0B527F, &HB22D)
	LASelfGain.Tag = ebEmptyText

	LASelfGain.LoadProperties
	LASelfGain.Subroutine = ebUCase_L & ebUCase_A & ebUCase_S & ebLCase_e & ebLCase_l & ebLCase_f & ebUCase_G & ebLCase_a & ebLCase_i & ebLCase_n & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set LASelfGain_theCollection = New RteCollection

	Set List3 = New List
	List3.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_3
	'{939EF956-2980-423B-8A12-C99444FFC622}
	List3.Guid = CGuid(&H939EF956, &H2980, &H423B, &H8A12, &HC99444FF, &HC622)
	List3.Tag = ebEmptyText

	'Initialization for List3

	Set List3.Order = New SequentialOrder
	Set List3.Deletion = NoDeletion
	List3.ResetEveryRun = False

	List3.LoadProperties

	Set List3.TerminateCondition = Cycles(1)
	Set List3.ResetCondition = Samples(3)
	List3.Reset

	Set Self1 = New Procedure
	Self1.Name = ebUCase_S & ebLCase_e & ebLCase_l & ebLCase_f & ebDigit_1
	'{77AF5EB9-3256-446E-B8F1-188E3E1BEC1A}
	Self1.Guid = CGuid(&H77AF5EB9, &H3256, &H446E, &HB8F1, &H188E3E1B, &HEC1A)
	Self1.Tag = ebEmptyText

	Self1.LoadProperties
	Self1.Subroutine = ebUCase_S & ebLCase_e & ebLCase_l & ebLCase_f & ebDigit_1 & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Self1_theCollection = New RteCollection

	Set Self2 = New Procedure
	Self2.Name = ebUCase_S & ebLCase_e & ebLCase_l & ebLCase_f & ebDigit_2
	'{90B7A441-5DA1-4500-8E21-79AA6B711D64}
	Self2.Guid = CGuid(&H90B7A441, &H5DA1, &H4500, &H8E21, &H79AA6B71, &H1D64)
	Self2.Tag = ebEmptyText

	Self2.LoadProperties
	Self2.Subroutine = ebUCase_S & ebLCase_e & ebLCase_l & ebLCase_f & ebDigit_2 & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Self2_theCollection = New RteCollection

	Set Self3 = New Procedure
	Self3.Name = ebUCase_S & ebLCase_e & ebLCase_l & ebLCase_f & ebDigit_3
	'{6801114D-555B-4588-BD56-F575591FF66C}
	Self3.Guid = CGuid(&H6801114D, &H555B, &H4588, &HBD56, &HF575591F, &HF66C)
	Self3.Tag = ebEmptyText

	Self3.LoadProperties
	Self3.Subroutine = ebUCase_S & ebLCase_e & ebLCase_l & ebLCase_f & ebDigit_3 & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Self3_theCollection = New RteCollection

	Set List4 = New List
	List4.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_4
	'{7A16961F-7FDC-44E6-8C0C-F54F1D1EFF21}
	List4.Guid = CGuid(&H7A16961F, &H7FDC, &H44E6, &H8C0C, &HF54F1D1E, &HFF21)
	List4.Tag = ebEmptyText

	'Initialization for List4

	Set List4.Order = New SequentialOrder
	Set List4.Deletion = NoDeletion
	List4.ResetEveryRun = False

	List4.LoadProperties

	Set List4.TerminateCondition = Cycles(1)
	Set List4.ResetCondition = Samples(30)
	List4.Reset

	Set List5 = New List
	List5.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_5
	'{FF3EDDF0-ABA9-41D4-9FC1-2E6ECC66999E}
	List5.Guid = CGuid(&HFF3EDDF0, &HABA9, &H41D4, &H9FC1, &H2E6ECC66, &H999E)
	List5.Tag = ebEmptyText

	'Initialization for List5

	Set List5.Order = New SequentialOrder
	Set List5.Deletion = NoDeletion
	List5.ResetEveryRun = False

	List5.LoadProperties

	Set List5.TerminateCondition = Cycles(1)
	Set List5.ResetCondition = Samples(30)
	List5.Reset

	Set List6 = New List
	List6.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_6
	'{56ED4A06-0B12-46BF-B9DA-217AD4A4D8DE}
	List6.Guid = CGuid(&H56ED4A06, &H0B12, &H46BF, &HB9DA, &H217AD4A4, &HD8DE)
	List6.Tag = ebEmptyText

	'Initialization for List6

	Set List6.Order = New SequentialOrder
	Set List6.Deletion = NoDeletion
	List6.ResetEveryRun = False

	List6.LoadProperties

	Set List6.TerminateCondition = Cycles(1)
	Set List6.ResetCondition = Samples(30)
	List6.Reset

	Set Instructions1 = New TextDisplay
	Instructions1.Name = ebUCase_I & ebLCase_n & ebLCase_s & ebLCase_t & ebLCase_r & ebLCase_u & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_s & ebDigit_1
	'{B4B36B73-B275-4890-B406-BF1A4C011005}
	Instructions1.Guid = CGuid(&HB4B36B73, &HB275, &H4890, &HB406, &HBF1A4C01, &H1005)
	Instructions1.Tag = ebEmptyText

	Set Instructions1EchoClients = New EchoClientCollection

	Instructions1.LoadProperties

	Set Instruction2 = New TextDisplay
	Instruction2.Name = ebUCase_I & ebLCase_n & ebLCase_s & ebLCase_t & ebLCase_r & ebLCase_u & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_2
	'{469C0CE6-13CE-4183-A3C8-49D683BB0417}
	Instruction2.Guid = CGuid(&H469C0CE6, &H13CE, &H4183, &HA3C8, &H49D683BB, &H0417)
	Instruction2.Tag = ebEmptyText

	Set Instruction2EchoClients = New EchoClientCollection

	Instruction2.LoadProperties

	Set List2 = New List
	List2.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_2
	'{577FE596-691E-498C-872C-3AF2BD104CBB}
	List2.Guid = CGuid(&H577FE596, &H691E, &H498C, &H872C, &H3AF2BD10, &H4CBB)
	List2.Tag = ebEmptyText

	'Initialization for List2

	Set List2.Order = New SequentialOrder
	Set List2.Deletion = NoDeletion
	List2.ResetEveryRun = False

	List2.LoadProperties

	Set List2.TerminateCondition = Cycles(1)
	Set List2.ResetCondition = Samples(3)
	List2.Reset

	Set List7 = New List
	List7.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_7
	'{14BB854E-3221-4097-8D09-F25531230F80}
	List7.Guid = CGuid(&H14BB854E, &H3221, &H4097, &H8D09, &HF2553123, &H0F80)
	List7.Tag = ebEmptyText

	'Initialization for List7

	Set List7.Order = New SequentialOrder
	Set List7.Deletion = NoDeletion
	List7.ResetEveryRun = False

	List7.LoadProperties

	Set List7.TerminateCondition = Cycles(1)
	Set List7.ResetCondition = Samples(30)
	List7.Reset

	Set List8 = New List
	List8.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_8
	'{B56DF973-1082-4B37-A398-CC144E1AA756}
	List8.Guid = CGuid(&HB56DF973, &H1082, &H4B37, &HA398, &HCC144E1A, &HA756)
	List8.Tag = ebEmptyText

	'Initialization for List8

	Set List8.Order = New SequentialOrder
	Set List8.Deletion = NoDeletion
	List8.ResetEveryRun = False

	List8.LoadProperties

	Set List8.TerminateCondition = Cycles(1)
	Set List8.ResetCondition = Samples(30)
	List8.Reset

	Set Other1 = New Procedure
	Other1.Name = ebUCase_O & ebLCase_t & ebLCase_h & ebLCase_e & ebLCase_r & ebDigit_1
	'{FBBF37A0-366A-4DAE-B045-EF397481C3F2}
	Other1.Guid = CGuid(&HFBBF37A0, &H366A, &H4DAE, &HB045, &HEF397481, &HC3F2)
	Other1.Tag = ebEmptyText

	Other1.LoadProperties
	Other1.Subroutine = ebUCase_O & ebLCase_t & ebLCase_h & ebLCase_e & ebLCase_r & ebDigit_1 & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Other1_theCollection = New RteCollection

	Set Other2 = New Procedure
	Other2.Name = ebUCase_O & ebLCase_t & ebLCase_h & ebLCase_e & ebLCase_r & ebDigit_2
	'{E4C8BE62-224A-4568-97C5-AA9F973BED83}
	Other2.Guid = CGuid(&HE4C8BE62, &H224A, &H4568, &H97C5, &HAA9F973B, &HED83)
	Other2.Tag = ebEmptyText

	Other2.LoadProperties
	Other2.Subroutine = ebUCase_O & ebLCase_t & ebLCase_h & ebLCase_e & ebLCase_r & ebDigit_2 & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Other2_theCollection = New RteCollection

	Set Other3 = New Procedure
	Other3.Name = ebUCase_O & ebLCase_t & ebLCase_h & ebLCase_e & ebLCase_r & ebDigit_3
	'{EC42E8B8-A306-42FD-88A0-FC7495606983}
	Other3.Guid = CGuid(&HEC42E8B8, &HA306, &H42FD, &H88A0, &HFC749560, &H6983)
	Other3.Tag = ebEmptyText

	Other3.LoadProperties
	Other3.Subroutine = ebUCase_O & ebLCase_t & ebLCase_h & ebLCase_e & ebLCase_r & ebDigit_3 & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Other3_theCollection = New RteCollection

	Set List9 = New List
	List9.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_9
	'{C7B2AD09-BEBC-44F0-8409-DFB56B02AE36}
	List9.Guid = CGuid(&HC7B2AD09, &HBEBC, &H44F0, &H8409, &HDFB56B02, &HAE36)
	List9.Tag = ebEmptyText

	'Initialization for List9

	Set List9.Order = New SequentialOrder
	Set List9.Deletion = NoDeletion
	List9.ResetEveryRun = False

	List9.LoadProperties

	Set List9.TerminateCondition = Cycles(1)
	Set List9.ResetCondition = Samples(30)
	List9.Reset

	Set List10 = New List
	List10.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_1 & ebDigit_0
	'{0FB44A4A-F3EB-4F5F-B673-DFA91654145D}
	List10.Guid = CGuid(&H0FB44A4A, &HF3EB, &H4F5F, &HB673, &HDFA91654, &H145D)
	List10.Tag = ebEmptyText

	'Initialization for List10

	Set List10.Order = New SequentialOrder
	Set List10.Deletion = NoDeletion
	List10.ResetEveryRun = False

	List10.LoadProperties

	Set List10.TerminateCondition = Cycles(1)
	Set List10.ResetCondition = Samples(3)
	List10.Reset

	Set Both1 = New Procedure
	Both1.Name = ebUCase_B & ebLCase_o & ebLCase_t & ebLCase_h & ebDigit_1
	'{680A24DE-0748-47F3-818F-C38114415E67}
	Both1.Guid = CGuid(&H680A24DE, &H0748, &H47F3, &H818F, &HC3811441, &H5E67)
	Both1.Tag = ebEmptyText

	Both1.LoadProperties
	Both1.Subroutine = ebUCase_B & ebLCase_o & ebLCase_t & ebLCase_h & ebDigit_1 & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Both1_theCollection = New RteCollection

	Set Both2 = New Procedure
	Both2.Name = ebUCase_B & ebLCase_o & ebLCase_t & ebLCase_h & ebDigit_2
	'{E8AEA161-CFDE-4423-8E25-74E05D36965E}
	Both2.Guid = CGuid(&HE8AEA161, &HCFDE, &H4423, &H8E25, &H74E05D36, &H965E)
	Both2.Tag = ebEmptyText

	Both2.LoadProperties
	Both2.Subroutine = ebUCase_B & ebLCase_o & ebLCase_t & ebLCase_h & ebDigit_2 & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Both2_theCollection = New RteCollection

	Set Both3 = New Procedure
	Both3.Name = ebUCase_B & ebLCase_o & ebLCase_t & ebLCase_h & ebDigit_3
	'{C3ABFFC7-C7C6-4B7F-9623-7BC39435720D}
	Both3.Guid = CGuid(&HC3ABFFC7, &HC7C6, &H4B7F, &H9623, &H7BC39435, &H720D)
	Both3.Tag = ebEmptyText

	Both3.LoadProperties
	Both3.Subroutine = ebUCase_B & ebLCase_o & ebLCase_t & ebLCase_h & ebDigit_3 & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Both3_theCollection = New RteCollection

	Set List11 = New List
	List11.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_1 & ebDigit_1
	'{B4399FDB-FF65-4F5B-A753-C16658BC0F40}
	List11.Guid = CGuid(&HB4399FDB, &HFF65, &H4F5B, &HA753, &HC16658BC, &H0F40)
	List11.Tag = ebEmptyText

	'Initialization for List11

	Set List11.Order = New SequentialOrder
	Set List11.Deletion = NoDeletion
	List11.ResetEveryRun = False

	List11.LoadProperties

	Set List11.TerminateCondition = Cycles(1)
	Set List11.ResetCondition = Samples(30)
	List11.Reset

	Set List12 = New List
	List12.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_1 & ebDigit_2
	'{98C269CA-25DB-4D5D-B12D-82FA1B945EFE}
	List12.Guid = CGuid(&H98C269CA, &H25DB, &H4D5D, &HB12D, &H82FA1B94, &H5EFE)
	List12.Tag = ebEmptyText

	'Initialization for List12

	Set List12.Order = New SequentialOrder
	Set List12.Deletion = NoDeletion
	List12.ResetEveryRun = False

	List12.LoadProperties

	Set List12.TerminateCondition = Cycles(1)
	Set List12.ResetCondition = Samples(30)
	List12.Reset

	Set List13 = New List
	List13.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_1 & ebDigit_3
	'{7DCB6052-1432-4556-B790-84BD7D98FD02}
	List13.Guid = CGuid(&H7DCB6052, &H1432, &H4556, &HB790, &H84BD7D98, &HFD02)
	List13.Tag = ebEmptyText

	'Initialization for List13

	Set List13.Order = New SequentialOrder
	Set List13.Deletion = NoDeletion
	List13.ResetEveryRun = False

	List13.LoadProperties

	Set List13.TerminateCondition = Cycles(1)
	Set List13.ResetCondition = Samples(30)
	List13.Reset

	Set LAOtherMixed = New Procedure
	LAOtherMixed.Name = ebUCase_L & ebUCase_A & ebUCase_O & ebLCase_t & ebLCase_h & ebLCase_e & ebLCase_r & ebUCase_M & ebLCase_i & ebLCase_x & ebLCase_e & ebLCase_d
	'{A4778376-96D8-49B2-9116-73DECB6FD260}
	LAOtherMixed.Guid = CGuid(&HA4778376, &H96D8, &H49B2, &H9116, &H73DECB6F, &HD260)
	LAOtherMixed.Tag = ebEmptyText

	LAOtherMixed.LoadProperties
	LAOtherMixed.Subroutine = ebUCase_L & ebUCase_A & ebUCase_O & ebLCase_t & ebLCase_h & ebLCase_e & ebLCase_r & ebUCase_M & ebLCase_i & ebLCase_x & ebLCase_e & ebLCase_d & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set LAOtherMixed_theCollection = New RteCollection

	Set LAOtherGain = New Procedure
	LAOtherGain.Name = ebUCase_L & ebUCase_A & ebUCase_O & ebLCase_t & ebLCase_h & ebLCase_e & ebLCase_r & ebUCase_G & ebLCase_a & ebLCase_i & ebLCase_n
	'{89A240CA-25B9-4986-A652-7F6E3ACDCB53}
	LAOtherGain.Guid = CGuid(&H89A240CA, &H25B9, &H4986, &HA652, &H7F6E3ACD, &HCB53)
	LAOtherGain.Tag = ebEmptyText

	LAOtherGain.LoadProperties
	LAOtherGain.Subroutine = ebUCase_L & ebUCase_A & ebUCase_O & ebLCase_t & ebLCase_h & ebLCase_e & ebLCase_r & ebUCase_G & ebLCase_a & ebLCase_i & ebLCase_n & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set LAOtherGain_theCollection = New RteCollection

	Set LABothMixed = New Procedure
	LABothMixed.Name = ebUCase_L & ebUCase_A & ebUCase_B & ebLCase_o & ebLCase_t & ebLCase_h & ebUCase_M & ebLCase_i & ebLCase_x & ebLCase_e & ebLCase_d
	'{2B1AF1E3-0D68-488A-BE7A-1769FED9FB14}
	LABothMixed.Guid = CGuid(&H2B1AF1E3, &H0D68, &H488A, &HBE7A, &H1769FED9, &HFB14)
	LABothMixed.Tag = ebEmptyText

	LABothMixed.LoadProperties
	LABothMixed.Subroutine = ebUCase_L & ebUCase_A & ebUCase_B & ebLCase_o & ebLCase_t & ebLCase_h & ebUCase_M & ebLCase_i & ebLCase_x & ebLCase_e & ebLCase_d & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set LABothMixed_theCollection = New RteCollection

	Set LABothGain = New Procedure
	LABothGain.Name = ebUCase_L & ebUCase_A & ebUCase_B & ebLCase_o & ebLCase_t & ebLCase_h & ebUCase_G & ebLCase_a & ebLCase_i & ebLCase_n
	'{76901830-91F0-4975-B6B7-D362CD78A2AF}
	LABothGain.Guid = CGuid(&H76901830, &H91F0, &H4975, &HB6B7, &HD362CD78, &HA2AF)
	LABothGain.Tag = ebEmptyText

	LABothGain.LoadProperties
	LABothGain.Subroutine = ebUCase_L & ebUCase_A & ebUCase_B & ebLCase_o & ebLCase_t & ebLCase_h & ebUCase_G & ebLCase_a & ebLCase_i & ebLCase_n & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set LABothGain_theCollection = New RteCollection

	Set InstructionOptions1 = New Slide
	InstructionOptions1.Name = ebUCase_I & ebLCase_n & ebLCase_s & ebLCase_t & ebLCase_r & ebLCase_u & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_O & ebLCase_p & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_s & ebDigit_1
	'{99B614B3-A6CD-4E51-BB76-986F9E02D4FE}
	InstructionOptions1.Guid = CGuid(&H99B614B3, &HA6CD, &H4E51, &HBB76, &H986F9E02, &HD4FE)
	InstructionOptions1.Tag = ebEmptyText

	Set InstructionOptions1EchoClients = New EchoClientCollection

	InstructionOptions1.LoadProperties

	Set InstructionResponse2 = New Slide
	InstructionResponse2.Name = ebUCase_I & ebLCase_n & ebLCase_s & ebLCase_t & ebLCase_r & ebLCase_u & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebDigit_2
	'{57150626-BB1F-41F4-AF1F-6C2D4A077ACF}
	InstructionResponse2.Guid = CGuid(&H57150626, &HBB1F, &H41F4, &HAF1F, &H6C2D4A07, &H7ACF)
	InstructionResponse2.Tag = ebEmptyText

	Set InstructionResponse2EchoClients = New EchoClientCollection

	InstructionResponse2.LoadProperties

	Set Instruction5 = New TextDisplay
	Instruction5.Name = ebUCase_I & ebLCase_n & ebLCase_s & ebLCase_t & ebLCase_r & ebLCase_u & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_5
	'{B51356AD-AFC0-47F2-8FF5-32C231BA01E6}
	Instruction5.Guid = CGuid(&HB51356AD, &HAFC0, &H47F2, &H8FF5, &H32C231BA, &H01E6)
	Instruction5.Tag = ebEmptyText

	Set Instruction5EchoClients = New EchoClientCollection

	Instruction5.LoadProperties

	Set Instruction6 = New TextDisplay
	Instruction6.Name = ebUCase_I & ebLCase_n & ebLCase_s & ebLCase_t & ebLCase_r & ebLCase_u & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_6
	'{D7FAEB9D-3C62-4881-BBB3-885D28DE4681}
	Instruction6.Guid = CGuid(&HD7FAEB9D, &H3C62, &H4881, &HBBB3, &H885D28DE, &H4681)
	Instruction6.Tag = ebEmptyText

	Set Instruction6EchoClients = New EchoClientCollection

	Instruction6.LoadProperties

	Set Instruction7 = New TextDisplay
	Instruction7.Name = ebUCase_I & ebLCase_n & ebLCase_s & ebLCase_t & ebLCase_r & ebLCase_u & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_7
	'{23EA37CE-5952-4419-AC30-20EA411255F4}
	Instruction7.Guid = CGuid(&H23EA37CE, &H5952, &H4419, &HAC30, &H20EA4112, &H55F4)
	Instruction7.Tag = ebEmptyText

	Set Instruction7EchoClients = New EchoClientCollection

	Instruction7.LoadProperties

	Set Instruction8 = New TextDisplay
	Instruction8.Name = ebUCase_I & ebLCase_n & ebLCase_s & ebLCase_t & ebLCase_r & ebLCase_u & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_8
	'{2779AC9A-EC21-40BA-B015-B7AEE304220D}
	Instruction8.Guid = CGuid(&H2779AC9A, &HEC21, &H40BA, &HB015, &HB7AEE304, &H220D)
	Instruction8.Tag = ebEmptyText

	Set Instruction8EchoClients = New EchoClientCollection

	Instruction8.LoadProperties

	Set Instruction9 = New TextDisplay
	Instruction9.Name = ebUCase_I & ebLCase_n & ebLCase_s & ebLCase_t & ebLCase_r & ebLCase_u & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_9
	'{115FF354-3196-4DDA-A098-73F41ADC84D2}
	Instruction9.Guid = CGuid(&H115FF354, &H3196, &H4DDA, &HA098, &H73F41ADC, &H84D2)
	Instruction9.Tag = ebEmptyText

	Set Instruction9EchoClients = New EchoClientCollection

	Instruction9.LoadProperties

	Set practiceoptions = New Slide
	practiceoptions.Name = ebLCase_p & ebLCase_r & ebLCase_a & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_c & ebLCase_e & ebLCase_o & ebLCase_p & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_s
	'{D97F9845-E439-4007-B100-677425BED395}
	practiceoptions.Guid = CGuid(&HD97F9845, &HE439, &H4007, &HB100, &H677425BE, &HD395)
	practiceoptions.Tag = ebEmptyText

	practiceoptions.LoadProperties

	Set practiceresponse = New Slide
	practiceresponse.Name = ebLCase_p & ebLCase_r & ebLCase_a & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_c & ebLCase_e & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e
	'{D7E0D97A-53DC-4A2F-BAAA-E53768353E4D}
	practiceresponse.Guid = CGuid(&HD7E0D97A, &H53DC, &H4A2F, &HBAAA, &HE5376835, &H3E4D)
	practiceresponse.Tag = ebEmptyText

	Set practiceresponseEchoClients = New EchoClientCollection

	practiceresponse.LoadProperties

	Set practiceresponse3 = New Slide
	practiceresponse3.Name = ebLCase_p & ebLCase_r & ebLCase_a & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_c & ebLCase_e & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebDigit_3
	'{D5FFA4F1-BED9-4EA5-9794-65B6C20B6EFF}
	practiceresponse3.Guid = CGuid(&HD5FFA4F1, &HBED9, &H4EA5, &H9794, &H65B6C20B, &H6EFF)
	practiceresponse3.Tag = ebEmptyText

	Set practiceresponse3EchoClients = New EchoClientCollection

	practiceresponse3.LoadProperties

	Set practiceoptions3 = New Slide
	practiceoptions3.Name = ebLCase_p & ebLCase_r & ebLCase_a & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_c & ebLCase_e & ebLCase_o & ebLCase_p & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_s & ebDigit_3
	'{7F24E25B-4E8F-4C54-9524-B2CA9C0AC294}
	practiceoptions3.Guid = CGuid(&H7F24E25B, &H4E8F, &H4C54, &H9524, &HB2CA9C0A, &HC294)
	practiceoptions3.Tag = ebEmptyText

	practiceoptions3.LoadProperties

	Set PracticeList = New List
	PracticeList.Name = ebUCase_P & ebLCase_r & ebLCase_a & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t
	'{FC248888-6745-41A8-A23E-29A799D0BC16}
	PracticeList.Guid = CGuid(&HFC248888, &H6745, &H41A8, &HA23E, &H29A799D0, &HBC16)
	PracticeList.Tag = ebEmptyText

	'Initialization for PracticeList

	Set PracticeList.Order = New SequentialOrder
	Set PracticeList.Deletion = NoDeletion
	PracticeList.ResetEveryRun = False

	PracticeList.LoadProperties

	Set PracticeList.TerminateCondition = Cycles(1)
	Set PracticeList.ResetCondition = Samples(1)
	PracticeList.Reset

	Set PracticeTrials = New Procedure
	PracticeTrials.Name = ebUCase_P & ebLCase_r & ebLCase_a & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_T & ebLCase_r & ebLCase_i & ebLCase_a & ebLCase_l & ebLCase_s
	'{E93493CE-8519-4F2C-B226-F782F73A3C00}
	PracticeTrials.Guid = CGuid(&HE93493CE, &H8519, &H4F2C, &HB226, &HF782F73A, &H3C00)
	PracticeTrials.Tag = ebEmptyText

	PracticeTrials.LoadProperties
	PracticeTrials.Subroutine = ebUCase_P & ebLCase_r & ebLCase_a & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_T & ebLCase_r & ebLCase_i & ebLCase_a & ebLCase_l & ebLCase_s & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set PracticeTrials_theCollection = New RteCollection

	Set List14 = New List
	List14.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_1 & ebDigit_4
	'{410B5EF0-A09C-4995-8A63-B69ADCCED834}
	List14.Guid = CGuid(&H410B5EF0, &HA09C, &H4995, &H8A63, &HB69ADCCE, &HD834)
	List14.Tag = ebEmptyText

	'Initialization for List14

	Set List14.Order = New SequentialOrder
	Set List14.Deletion = NoDeletion
	List14.ResetEveryRun = False

	List14.LoadProperties

	Set List14.TerminateCondition = Cycles(1)
	Set List14.ResetCondition = Samples(4)
	List14.Reset

	Set PracticeMixed = New Procedure
	PracticeMixed.Name = ebUCase_P & ebLCase_r & ebLCase_a & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_M & ebLCase_i & ebLCase_x & ebLCase_e & ebLCase_d
	'{1317F49B-9178-48DF-9C15-28CB48DA42E4}
	PracticeMixed.Guid = CGuid(&H1317F49B, &H9178, &H48DF, &H9C15, &H28CB48DA, &H42E4)
	PracticeMixed.Tag = ebEmptyText

	PracticeMixed.LoadProperties
	PracticeMixed.Subroutine = ebUCase_P & ebLCase_r & ebLCase_a & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_M & ebLCase_i & ebLCase_x & ebLCase_e & ebLCase_d & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set PracticeMixed_theCollection = New RteCollection

	Set PracticeGain = New Procedure
	PracticeGain.Name = ebUCase_P & ebLCase_r & ebLCase_a & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_G & ebLCase_a & ebLCase_i & ebLCase_n
	'{5EF54177-B821-4C0E-B7D3-9EE51E30EB39}
	PracticeGain.Guid = CGuid(&H5EF54177, &HB821, &H4C0E, &HB7D3, &H9EE51E30, &HEB39)
	PracticeGain.Tag = ebEmptyText

	PracticeGain.LoadProperties
	PracticeGain.Subroutine = ebUCase_P & ebLCase_r & ebLCase_a & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_G & ebLCase_a & ebLCase_i & ebLCase_n & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set PracticeGain_theCollection = New RteCollection

	Set FeedbackDisplay2 = New FeedbackDisplay
	FeedbackDisplay2.Name = ebUCase_F & ebLCase_e & ebLCase_e & ebLCase_d & ebLCase_b & ebLCase_a & ebLCase_c & ebLCase_k & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDigit_2
	'{0CEC58D1-0570-43A3-B4A5-5A9B1929FE13}
	FeedbackDisplay2.Guid = CGuid(&H0CEC58D1, &H0570, &H43A3, &HB4A5, &H5A9B1929, &HFE13)
	FeedbackDisplay2.Tag = ebEmptyText

	FeedbackDisplay2.LoadProperties

	Set FeedbackDisplay4 = New FeedbackDisplay
	FeedbackDisplay4.Name = ebUCase_F & ebLCase_e & ebLCase_e & ebLCase_d & ebLCase_b & ebLCase_a & ebLCase_c & ebLCase_k & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDigit_4
	'{74ECA310-7911-49B4-9F8A-D4B19D0D2250}
	FeedbackDisplay4.Guid = CGuid(&H74ECA310, &H7911, &H49B4, &H9F8A, &HD4B19D0D, &H2250)
	FeedbackDisplay4.Tag = ebEmptyText

	FeedbackDisplay4.LoadProperties

	Set SelfSpaceBar1 = New TextDisplay
	SelfSpaceBar1.Name = ebUCase_S & ebLCase_e & ebLCase_l & ebLCase_f & ebUCase_S & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebUCase_B & ebLCase_a & ebLCase_r & ebDigit_1
	'{C805A5FA-DD45-4BF5-AE96-F558C55DF50A}
	SelfSpaceBar1.Guid = CGuid(&HC805A5FA, &HDD45, &H4BF5, &HAE96, &HF558C55D, &HF50A)
	SelfSpaceBar1.Tag = ebEmptyText

	Set SelfSpaceBar1EchoClients = New EchoClientCollection

	SelfSpaceBar1.LoadProperties

	Set SelfSpaceBar2 = New TextDisplay
	SelfSpaceBar2.Name = ebUCase_S & ebLCase_e & ebLCase_l & ebLCase_f & ebUCase_S & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebUCase_B & ebLCase_a & ebLCase_r & ebDigit_2
	'{AB483391-BBE6-4CF3-AE61-F7BC9BA6AFE3}
	SelfSpaceBar2.Guid = CGuid(&HAB483391, &HBBE6, &H4CF3, &HAE61, &HF7BC9BA6, &HAFE3)
	SelfSpaceBar2.Tag = ebEmptyText

	Set SelfSpaceBar2EchoClients = New EchoClientCollection

	SelfSpaceBar2.LoadProperties

	Set SelfSpaceBar3 = New TextDisplay
	SelfSpaceBar3.Name = ebUCase_S & ebLCase_e & ebLCase_l & ebLCase_f & ebUCase_S & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebUCase_B & ebLCase_a & ebLCase_r & ebDigit_3
	'{FB658FE8-40AB-43A1-BCC3-75BCDE009F7B}
	SelfSpaceBar3.Guid = CGuid(&HFB658FE8, &H40AB, &H43A1, &HBCC3, &H75BCDE00, &H9F7B)
	SelfSpaceBar3.Tag = ebEmptyText

	Set SelfSpaceBar3EchoClients = New EchoClientCollection

	SelfSpaceBar3.LoadProperties

	Set OtherSpaceBar1 = New TextDisplay
	OtherSpaceBar1.Name = ebUCase_O & ebLCase_t & ebLCase_h & ebLCase_e & ebLCase_r & ebUCase_S & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebUCase_B & ebLCase_a & ebLCase_r & ebDigit_1
	'{73381F3B-1878-4A3A-9556-5B25FCBC955B}
	OtherSpaceBar1.Guid = CGuid(&H73381F3B, &H1878, &H4A3A, &H9556, &H5B25FCBC, &H955B)
	OtherSpaceBar1.Tag = ebEmptyText

	Set OtherSpaceBar1EchoClients = New EchoClientCollection

	OtherSpaceBar1.LoadProperties

	Set OtherSpaceBar2 = New TextDisplay
	OtherSpaceBar2.Name = ebUCase_O & ebLCase_t & ebLCase_h & ebLCase_e & ebLCase_r & ebUCase_S & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebUCase_B & ebLCase_a & ebLCase_r & ebDigit_2
	'{55699C67-F2A6-475E-BCBE-04748227F2FC}
	OtherSpaceBar2.Guid = CGuid(&H55699C67, &HF2A6, &H475E, &HBCBE, &H04748227, &HF2FC)
	OtherSpaceBar2.Tag = ebEmptyText

	Set OtherSpaceBar2EchoClients = New EchoClientCollection

	OtherSpaceBar2.LoadProperties

	Set BothSpaceBar1 = New TextDisplay
	BothSpaceBar1.Name = ebUCase_B & ebLCase_o & ebLCase_t & ebLCase_h & ebUCase_S & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebUCase_B & ebLCase_a & ebLCase_r & ebDigit_1
	'{AEAB43CC-5036-452E-A624-06B28BEB31F0}
	BothSpaceBar1.Guid = CGuid(&HAEAB43CC, &H5036, &H452E, &HA624, &H06B28BEB, &H31F0)
	BothSpaceBar1.Tag = ebEmptyText

	Set BothSpaceBar1EchoClients = New EchoClientCollection

	BothSpaceBar1.LoadProperties

	Set OtherSpaceBar3 = New TextDisplay
	OtherSpaceBar3.Name = ebUCase_O & ebLCase_t & ebLCase_h & ebLCase_e & ebLCase_r & ebUCase_S & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebUCase_B & ebLCase_a & ebLCase_r & ebDigit_3
	'{4A009CB9-5EDD-4F16-8DEB-0CBA9DA3132F}
	OtherSpaceBar3.Guid = CGuid(&H4A009CB9, &H5EDD, &H4F16, &H8DEB, &H0CBA9DA3, &H132F)
	OtherSpaceBar3.Tag = ebEmptyText

	Set OtherSpaceBar3EchoClients = New EchoClientCollection

	OtherSpaceBar3.LoadProperties

	Set BothSpaceBar2 = New TextDisplay
	BothSpaceBar2.Name = ebUCase_B & ebLCase_o & ebLCase_t & ebLCase_h & ebUCase_S & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebUCase_B & ebLCase_a & ebLCase_r & ebDigit_2
	'{50568C89-DA75-4BFE-A5D2-3837E574C1E0}
	BothSpaceBar2.Guid = CGuid(&H50568C89, &HDA75, &H4BFE, &HA5D2, &H3837E574, &HC1E0)
	BothSpaceBar2.Tag = ebEmptyText

	Set BothSpaceBar2EchoClients = New EchoClientCollection

	BothSpaceBar2.LoadProperties

	Set BothSpaceBar3 = New TextDisplay
	BothSpaceBar3.Name = ebUCase_B & ebLCase_o & ebLCase_t & ebLCase_h & ebUCase_S & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebUCase_B & ebLCase_a & ebLCase_r & ebDigit_3
	'{1195683F-2F0C-4D5A-B5B5-21DA31BED0BA}
	BothSpaceBar3.Guid = CGuid(&H1195683F, &H2F0C, &H4D5A, &HB5B5, &H21DA31BE, &HD0BA)
	BothSpaceBar3.Tag = ebEmptyText

	Set BothSpaceBar3EchoClients = New EchoClientCollection

	BothSpaceBar3.LoadProperties

	Set OtherBlockInstructions = New Slide
	OtherBlockInstructions.Name = ebUCase_O & ebLCase_t & ebLCase_h & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_l & ebLCase_o & ebLCase_c & ebLCase_k & ebUCase_I & ebLCase_n & ebLCase_s & ebLCase_t & ebLCase_r & ebLCase_u & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_s
	'{C54C0E47-1766-4C92-8FB1-B0D3913E2260}
	OtherBlockInstructions.Guid = CGuid(&HC54C0E47, &H1766, &H4C92, &H8FB1, &HB0D3913E, &H2260)
	OtherBlockInstructions.Tag = ebEmptyText

	Set OtherBlockInstructionsEchoClients = New EchoClientCollection

	OtherBlockInstructions.LoadProperties

	Set BothBlockInstructions = New Slide
	BothBlockInstructions.Name = ebUCase_B & ebLCase_o & ebLCase_t & ebLCase_h & ebUCase_B & ebLCase_l & ebLCase_o & ebLCase_c & ebLCase_k & ebUCase_I & ebLCase_n & ebLCase_s & ebLCase_t & ebLCase_r & ebLCase_u & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_s
	'{67FDD552-82EB-411F-91EF-4CBB38540F71}
	BothBlockInstructions.Guid = CGuid(&H67FDD552, &H82EB, &H411F, &H91EF, &H4CBB3854, &H0F71)
	BothBlockInstructions.Tag = ebEmptyText

	Set BothBlockInstructionsEchoClients = New EchoClientCollection

	BothBlockInstructions.LoadProperties

	Set OtherFB = New FeedbackDisplay
	OtherFB.Name = ebUCase_O & ebLCase_t & ebLCase_h & ebLCase_e & ebLCase_r & ebUCase_F & ebUCase_B
	'{3452E8D5-BA70-488A-8B5A-F05221B2ADF9}
	OtherFB.Guid = CGuid(&H3452E8D5, &HBA70, &H488A, &H8B5A, &HF05221B2, &HADF9)
	OtherFB.Tag = ebEmptyText

	OtherFB.LoadProperties

	Set SelfFB = New FeedbackDisplay
	SelfFB.Name = ebUCase_S & ebLCase_e & ebLCase_l & ebLCase_f & ebUCase_F & ebUCase_B
	'{52AC4F7F-45AB-44E4-90C2-7180F9D216E5}
	SelfFB.Guid = CGuid(&H52AC4F7F, &H45AB, &H44E4, &H90C2, &H7180F9D2, &H16E5)
	SelfFB.Tag = ebEmptyText

	SelfFB.LoadProperties

	Set thanksforplaying = New TextDisplay
	thanksforplaying.Name = ebLCase_t & ebLCase_h & ebLCase_a & ebLCase_n & ebLCase_k & ebLCase_s & ebLCase_f & ebLCase_o & ebLCase_r & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebLCase_i & ebLCase_n & ebLCase_g
	'{A79EC04C-5D98-4B3C-8434-C18A2C617F56}
	thanksforplaying.Guid = CGuid(&HA79EC04C, &H5D98, &H4B3C, &H8434, &HC18A2C61, &H7F56)
	thanksforplaying.Tag = ebEmptyText

	Set thanksforplayingEchoClients = New EchoClientCollection

	thanksforplaying.LoadProperties

	Set RatingsList = New List
	RatingsList.Name = ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s & ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t
	'{ADF2511D-4459-4741-954D-38724798E43B}
	RatingsList.Guid = CGuid(&HADF2511D, &H4459, &H4741, &H954D, &H38724798, &HE43B)
	RatingsList.Tag = ebEmptyText

	'Initialization for RatingsList

	Set RatingsList.Order = New SequentialOrder
	Set RatingsList.Deletion = NoDeletion
	RatingsList.ResetEveryRun = False

	RatingsList.LoadProperties

	Set RatingsList.TerminateCondition = Cycles(1)
	Set RatingsList.ResetCondition = Samples(6)
	RatingsList.Reset

	Set selfratings = New Procedure
	selfratings.Name = ebLCase_s & ebLCase_e & ebLCase_l & ebLCase_f & ebLCase_r & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s
	'{C4E46675-8411-443A-B595-3DBE7B07C52A}
	selfratings.Guid = CGuid(&HC4E46675, &H8411, &H443A, &HB595, &H3DBE7B07, &HC52A)
	selfratings.Tag = ebEmptyText

	selfratings.LoadProperties
	selfratings.Subroutine = ebLCase_s & ebLCase_e & ebLCase_l & ebLCase_f & ebLCase_r & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set selfratings_theCollection = New RteCollection

	Set otherratings = New Procedure
	otherratings.Name = ebLCase_o & ebLCase_t & ebLCase_h & ebLCase_e & ebLCase_r & ebLCase_r & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s
	'{E698A73F-C454-401E-8F2A-94E1D85FA1CB}
	otherratings.Guid = CGuid(&HE698A73F, &HC454, &H401E, &H8F2A, &H94E1D85F, &HA1CB)
	otherratings.Tag = ebEmptyText

	otherratings.LoadProperties
	otherratings.Subroutine = ebLCase_o & ebLCase_t & ebLCase_h & ebLCase_e & ebLCase_r & ebLCase_r & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set otherratings_theCollection = New RteCollection

	Set sharedratings = New Procedure
	sharedratings.Name = ebLCase_s & ebLCase_h & ebLCase_a & ebLCase_r & ebLCase_e & ebLCase_d & ebLCase_r & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s
	'{21F290D6-F098-47F9-9F95-5E210071986A}
	sharedratings.Guid = CGuid(&H21F290D6, &HF098, &H47F9, &H9F95, &H5E210071, &H986A)
	sharedratings.Tag = ebEmptyText

	sharedratings.LoadProperties
	sharedratings.Subroutine = ebLCase_s & ebLCase_h & ebLCase_a & ebLCase_r & ebLCase_e & ebLCase_d & ebLCase_r & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set sharedratings_theCollection = New RteCollection

	Set SelfOutcomes = New Slide
	SelfOutcomes.Name = ebUCase_S & ebLCase_e & ebLCase_l & ebLCase_f & ebUCase_O & ebLCase_u & ebLCase_t & ebLCase_c & ebLCase_o & ebLCase_m & ebLCase_e & ebLCase_s
	'{64BD61BC-AC22-4EB7-BE84-C95ED75170FB}
	SelfOutcomes.Guid = CGuid(&H64BD61BC, &HAC22, &H4EB7, &HBE84, &HC95ED751, &H70FB)
	SelfOutcomes.Tag = ebEmptyText

	Set SelfOutcomesEchoClients = New EchoClientCollection

	SelfOutcomes.LoadProperties

	Set OtherOutcomes = New Slide
	OtherOutcomes.Name = ebUCase_O & ebLCase_t & ebLCase_h & ebLCase_e & ebLCase_r & ebUCase_O & ebLCase_u & ebLCase_t & ebLCase_c & ebLCase_o & ebLCase_m & ebLCase_e & ebLCase_s
	'{7077C40D-DDB9-4570-8F6D-25CF9A96E0D8}
	OtherOutcomes.Guid = CGuid(&H7077C40D, &HDDB9, &H4570, &H8F6D, &H25CF9A96, &HE0D8)
	OtherOutcomes.Tag = ebEmptyText

	Set OtherOutcomesEchoClients = New EchoClientCollection

	OtherOutcomes.LoadProperties

	Set SharedOutcomes = New Slide
	SharedOutcomes.Name = ebUCase_S & ebLCase_h & ebLCase_a & ebLCase_r & ebLCase_e & ebLCase_d & ebUCase_O & ebLCase_u & ebLCase_t & ebLCase_c & ebLCase_o & ebLCase_m & ebLCase_e & ebLCase_s
	'{1BBC0050-8DA3-46B7-B3DF-0AC70CB8BCE9}
	SharedOutcomes.Guid = CGuid(&H1BBC0050, &H8DA3, &H46B7, &HB3DF, &H0AC70CB8, &HBCE9)
	SharedOutcomes.Tag = ebEmptyText

	Set SharedOutcomesEchoClients = New EchoClientCollection

	SharedOutcomes.LoadProperties

	Set pleasenotify = New TextDisplay
	pleasenotify.Name = ebLCase_p & ebLCase_l & ebLCase_e & ebLCase_a & ebLCase_s & ebLCase_e & ebLCase_n & ebLCase_o & ebLCase_t & ebLCase_i & ebLCase_f & ebLCase_y
	'{64DB64EE-60F3-4D56-9AD4-7D3DDC98C265}
	pleasenotify.Guid = CGuid(&H64DB64EE, &H60F3, &H4D56, &H9AD4, &H7D3DDC98, &HC265)
	pleasenotify.Tag = ebEmptyText

	Set pleasenotifyEchoClients = New EchoClientCollection

	pleasenotify.LoadProperties

	Set ITIList = New List
	ITIList.Name = ebUCase_I & ebUCase_T & ebUCase_I & ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t
	'{92078FB7-DE0C-408E-B4BE-BCAB8E724D0E}
	ITIList.Guid = CGuid(&H92078FB7, &HDE0C, &H408E, &HB4BE, &HBCAB8E72, &H4D0E)
	ITIList.Tag = ebEmptyText

	'Initialization for ITIList

	Set ITIList.Order = New RandomOrder
	CRandomOrder(ITIList.Order).NoRepeatAfterReset = True
	Set ITIList.Deletion = NoDeletion
	ITIList.ResetEveryRun = False

	ITIList.LoadProperties

	Set ITIList.TerminateCondition = Cycles(1)
	Set ITIList.ResetCondition = Samples(30)
	ITIList.Reset

	Set ITIPrac = New TextDisplay
	ITIPrac.Name = ebUCase_I & ebUCase_T & ebUCase_I & ebUCase_P & ebLCase_r & ebLCase_a & ebLCase_c
	'{67E5279B-C9B7-465E-9219-8B662567D872}
	ITIPrac.Guid = CGuid(&H67E5279B, &HC9B7, &H465E, &H9219, &H8B662567, &HD872)
	ITIPrac.Tag = ebEmptyText

	ITIPrac.LoadProperties


End Sub


'--------------------------------------------------------------------------
' InitPackages
'
'--------------------------------------------------------------------------
Sub InitPackages(c As Context)

End Sub



'--------------------------------------------------------------------------
' InitGlobals
'
'--------------------------------------------------------------------------
Sub InitGlobals(c As Context)


	'Assign Context to the StartupInfo object
	Set Rte.StartupInfo.Context = c

	'Load and Transfer external StartupInfo
	Rte.StartupInfo.Load
	Rte.StartupInfo.Transfer

End Sub



'--------------------------------------------------------------------------


'--------------------------------------------------------------------------
'--------------------------------------------------------------------------
' UnInitGlobals
'--------------------------------------------------------------------------
Sub UnInitGlobals()

	'Close the external StartupInfo
	Rte.StartupInfo.Close

End Sub
'--------------------------------------------------------------------------
' UnInitDevices
'--------------------------------------------------------------------------
Sub UnInitDevices()

	'UnInit All Devices
	Rte.DeviceManager.UnInit
	Display.Close
	Set Display = Nothing

	Keyboard.Close
	Set Keyboard = Nothing

	Mouse.Close
	Set Mouse = Nothing

	Sound.Close
	ParallelPort.Close
	Set ParallelPort = Nothing
End Sub


'--------------------------------------------------------------------------
'--------------------------------------------------------------------------
' UnInitPackages
'--------------------------------------------------------------------------
Sub UnInitPackages()
End Sub


'--------------------------------------------------------------------------
' UnInitObjects
'
'--------------------------------------------------------------------------
Sub UnInitObjects()

	Set SessionProc = Nothing

	Set List1 = Nothing

	Set Instructions = Nothing

	Set Ratings = Nothing

	Set SelfTask = Nothing

	Set OtherTask = Nothing

	Set BothTask = Nothing

	Set ITI = Nothing

	Set Options = Nothing

	Set ISI = Nothing

	Set Response = Nothing

	Set ResponseEchoClients = Nothing

	Set BothFB = Nothing

	Set LASelfMixed = Nothing

	Set LASelfGain = Nothing

	Set List3 = Nothing

	Set Self1 = Nothing

	Set Self2 = Nothing

	Set Self3 = Nothing

	Set List4 = Nothing

	Set List5 = Nothing

	Set List6 = Nothing

	Set Instructions1 = Nothing

	Set Instructions1EchoClients = Nothing

	Set Instruction2 = Nothing

	Set Instruction2EchoClients = Nothing

	Set List2 = Nothing

	Set List7 = Nothing

	Set List8 = Nothing

	Set Other1 = Nothing

	Set Other2 = Nothing

	Set Other3 = Nothing

	Set List9 = Nothing

	Set List10 = Nothing

	Set Both1 = Nothing

	Set Both2 = Nothing

	Set Both3 = Nothing

	Set List11 = Nothing

	Set List12 = Nothing

	Set List13 = Nothing

	Set LAOtherMixed = Nothing

	Set LAOtherGain = Nothing

	Set LABothMixed = Nothing

	Set LABothGain = Nothing

	Set InstructionOptions1 = Nothing

	Set InstructionOptions1EchoClients = Nothing

	Set InstructionResponse2 = Nothing

	Set InstructionResponse2EchoClients = Nothing

	Set Instruction5 = Nothing

	Set Instruction5EchoClients = Nothing

	Set Instruction6 = Nothing

	Set Instruction6EchoClients = Nothing

	Set Instruction7 = Nothing

	Set Instruction7EchoClients = Nothing

	Set Instruction8 = Nothing

	Set Instruction8EchoClients = Nothing

	Set Instruction9 = Nothing

	Set Instruction9EchoClients = Nothing

	Set practiceoptions = Nothing

	Set practiceresponse = Nothing

	Set practiceresponseEchoClients = Nothing

	Set practiceresponse3 = Nothing

	Set practiceresponse3EchoClients = Nothing

	Set practiceoptions3 = Nothing

	Set PracticeList = Nothing

	Set PracticeTrials = Nothing

	Set List14 = Nothing

	Set PracticeMixed = Nothing

	Set PracticeGain = Nothing

	Set FeedbackDisplay2 = Nothing

	Set FeedbackDisplay4 = Nothing

	Set SelfSpaceBar1 = Nothing

	Set SelfSpaceBar1EchoClients = Nothing

	Set SelfSpaceBar2 = Nothing

	Set SelfSpaceBar2EchoClients = Nothing

	Set SelfSpaceBar3 = Nothing

	Set SelfSpaceBar3EchoClients = Nothing

	Set OtherSpaceBar1 = Nothing

	Set OtherSpaceBar1EchoClients = Nothing

	Set OtherSpaceBar2 = Nothing

	Set OtherSpaceBar2EchoClients = Nothing

	Set BothSpaceBar1 = Nothing

	Set BothSpaceBar1EchoClients = Nothing

	Set OtherSpaceBar3 = Nothing

	Set OtherSpaceBar3EchoClients = Nothing

	Set BothSpaceBar2 = Nothing

	Set BothSpaceBar2EchoClients = Nothing

	Set BothSpaceBar3 = Nothing

	Set BothSpaceBar3EchoClients = Nothing

	Set OtherBlockInstructions = Nothing

	Set OtherBlockInstructionsEchoClients = Nothing

	Set BothBlockInstructions = Nothing

	Set BothBlockInstructionsEchoClients = Nothing

	Set OtherFB = Nothing

	Set SelfFB = Nothing

	Set thanksforplaying = Nothing

	Set thanksforplayingEchoClients = Nothing

	Set RatingsList = Nothing

	Set selfratings = Nothing

	Set otherratings = Nothing

	Set sharedratings = Nothing

	Set SelfOutcomes = Nothing

	Set SelfOutcomesEchoClients = Nothing

	Set OtherOutcomes = Nothing

	Set OtherOutcomesEchoClients = Nothing

	Set SharedOutcomes = Nothing

	Set SharedOutcomesEchoClients = Nothing

	Set pleasenotify = Nothing

	Set pleasenotifyEchoClients = Nothing

	Set ITIList = Nothing

	Set ITIPrac = Nothing


End Sub


'--------------------------------------------------------------------------
' Main
'
'--------------------------------------------------------------------------
Sub Main()

	' Create and initialize the default context, data file,
	' and provide global access to the context.
	Dim c As Context
	Set c = New Context
	c.Name = "ebContext"
	Set c.DataFile = New DataFile
	c.PushNewFrame
	Set ebContext = c

	' Set the log level names
	c.SetLogLevelName 1, "Session"
	c.SetLogLevelName 2, "Block"
	c.SetLogLevelName 3, "Trial"
	c.SetLogLevelName 4, "SubTrial"
	c.SetLogLevelName 5, "LogLevel5"
	c.SetLogLevelName 6, "LogLevel6"
	c.SetLogLevelName 7, "LogLevel7"
	c.SetLogLevelName 8, "LogLevel8"
	c.SetLogLevelName 9, "LogLevel9"
	c.SetLogLevelName 10, "LogLevel10"

	' Set standard logging items
	ebContext.SetAttrib "Experiment", "SLA_v1a_withpractice_FriendNew_8_11_16_ORDER2"
	ebContext.SetAttrib "SessionDate", Date$
	ebContext.SetAttrib "SessionTime", Time$
	ebContext.SetAttrib "SessionStartDateTimeUtc", NowUtc()

	'Initialize global variables for packages
	InitGlobals c

	' Initialize the Display Device(s) for runtime
	Dim DisplayDisplayDeviceInfo As DisplayDeviceInfo
	DisplayDisplayDeviceInfo.DefaultColor = Color.Black
	DisplayDisplayDeviceInfo.DisplayIndex = 1
	If c.AttribExists(ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDot & ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r) Then DisplayDisplayDeviceInfo.DefaultColor = CColor(c.GetAttrib(ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDot & ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r))
	If c.AttribExists(ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDot & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_I & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_x) Then DisplayDisplayDeviceInfo.DisplayIndex = CLng(c.GetAttrib(ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDot & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_I & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_x))



	CreateDefaultPort DisplayDisplayDeviceInfo.DefaultColor, "", DisplayDisplayDeviceInfo.DisplayIndex

	If Basic.OS = ebWin32 Then
		WinActivate "E-Run Experiment Window"
	End If

	' Get the StartupInfo

	' Set the defaults for all of the StartupInfo
	If Not c.AttribExists("Subject") Then c.SetAttrib "Subject", "1"
	If Not c.AttribExists("Session") Then c.SetAttrib "Session", "1"
	If Not c.AttribExists("Age") Then c.SetAttrib "Age", "0"
	If Not c.AttribExists("Sex") Then c.SetAttrib "Sex", "male"

	' Determine if StartupInfo.UseDefaults exists and is True/False to override prompts for StartupInfo parameters
	Dim bStartupInfoUseDefaults As Boolean
	bStartupInfoUseDefaults = False
	If c.AttribExists("StartupInfo.UseDefaults") Then bStartupInfoUseDefaults = CLogical(c.GetAttrib("StartupInfo.UseDefaults"))
	If Not bStartupInfoUseDefaults Then

		Dim vAnswer As Variant
StartupInfo_Begin:

StartupInfoPrompt_Subject:
		vAnswer = AskBox("Please enter the Subject Number (0=No Data Logging):", c.GetAttrib("Subject"))
		If Not IsEmpty(vAnswer) then
			If Not IsNumeric(vAnswer) then
				MsgBox "Please enter an integer value"
				GoTo StartupInfoPrompt_Subject
			ElseIf CLng(vAnswer) < 0 Then
				MsgBox "The value for Subject must not be less than 0"
				GoTo StartupInfoPrompt_Subject
			ElseIf CLng(vAnswer) > 2147483647 Then
				MsgBox "The value for Subject must not be greater than 2147483647"
				GoTo StartupInfoPrompt_Subject
			End If
		Else
			GoTo ExperimentAbort
		End if

		c.SetAttrib "Subject", CStr(vAnswer)

StartupInfoPrompt_Session:
		vAnswer = AskBox("Please enter the Session Number (1-32767):", c.GetAttrib("Session"))
		If Not IsEmpty(vAnswer) then
			If Not IsNumeric(vAnswer) then
				MsgBox "Please enter an integer value"
				GoTo StartupInfoPrompt_Session
			ElseIf CLng(vAnswer) < 1 Then
				MsgBox "The value for Session must not be less than 1"
				GoTo StartupInfoPrompt_Session
			ElseIf CLng(vAnswer) > 32767 Then
				MsgBox "The value for Session must not be greater than 32767"
				GoTo StartupInfoPrompt_Session
			End If
		Else
			GoTo ExperimentAbort
		End if

		c.SetAttrib "Session", CStr(vAnswer)

StartupInfoPrompt_Age:
		vAnswer = AskBox("Please enter Subject's Age (0-150):", c.GetAttrib("Age"))
		If Not IsEmpty(vAnswer) then
			If Not IsNumeric(vAnswer) then
				MsgBox "Please enter an integer value"
				GoTo StartupInfoPrompt_Age
			ElseIf CLng(vAnswer) < 0 Then
				MsgBox "The value for Age must not be less than 0"
				GoTo StartupInfoPrompt_Age
			ElseIf CLng(vAnswer) > 150 Then
				MsgBox "The value for Age must not be greater than 150"
				GoTo StartupInfoPrompt_Age
			End If
		Else
			GoTo ExperimentAbort
		End if

		c.SetAttrib "Age", CStr(vAnswer)

StartupInfoPrompt_Sex:
		Dim arrayChoicesSex(2)
		arrayChoicesSex(0) = "male"
		arrayChoicesSex(1) = "female"
		vAnswer = SelectBox(, "Please enter Subject's Sex:", arrayChoicesSex)
		If vAnswer >= 0 then
			c.SetAttrib "Sex", arrayChoicesSex(vAnswer)
		Else
			GoTo ExperimentAbort
		End If

		' Display the summary
		Dim strSummary As String
		strSummary = "Subject:    " & c.GetAttrib("Subject") & "\n"
		strSummary = strSummary & "Session:    " & c.GetAttrib("Session") & "\n"
		strSummary = strSummary & "Age:    " & c.GetAttrib("Age") & "\n"
		strSummary = strSummary & "Sex:    " & c.GetAttrib("Sex") & "\n"
		strSummary = strSummary & "\nContinue with the above startup info?"

		Dim nSummaryAnswer As Integer
		nSummaryAnswer = MsgBox(strSummary, ebYesNoCancel + ebQuestion, "Summary of Startup Info")
		If nSummaryAnswer = ebNo Then
				GoTo StartupInfo_Begin
		ElseIf nSummaryAnswer = ebCancel Then
				GoTo ExperimentAbort
		End If

	End If


	'Assign the Clock.Scale value
	Clock.Scale = 1.000000

	'If the attribute Clock.Scale.Override exists
	'  then use it for to set the Clock.Scale value
	If c.AttribExists("Clock.Scale.Override") Then
		Clock.Scale = CDbl(c.GetAttrib("Clock.Scale.Override"))
	End If

	' Set the Filenames for the data files
	Dim strFilenameBase As String
	Dim strFilenameRecovery As String
	Dim strFilenameEDAT As String

	'If the attribute DataFile.Filename.Override exists
	'  then use it for the .txt and .edat2 filenames
	If c.AttribExists("DataFile.Filename.Override") Then

		' Set the default Data Filename
		strFilenameBase = CStr(c.GetAttrib("DataFile.Filename.Override"))

	Else

		' Set the default Data Filename
		strFilenameBase = c.GetAttrib("Experiment") &_
				"-" &_
				c.GetAttrib("Subject") &_
				"-" &_
				c.GetAttrib("Session")

	End If

	'Set the name of the data file
	strFilenameRecovery = strFilenameBase & ".txt"
	strFilenameEDAT = strFilenameBase & ".edat2"
	c.DataFile.Filename = strFilenameRecovery
	c.SetAttrib "DataFile.Basename", strFilenameBase

	' If we are logging data, then prompt to overwrite the data file if it exists
	If CLng(c.GetAttrib("Subject")) <> 0 Then
		If FileExists(c.DataFile.Filename) Or FileExists(strFilenameEDAT) Then
			If ebYes <> MsgBox("WARNING: The data file and/or recovery file already exists:\nFILE: " & c.DataFile.Filename & "\n\nDo you want to overwrite?", ebYesNo + ebQuestion) Then
				GoTo ExperimentAbort
			End If
			' If you receive an error here then ensure that your E-Recovery (txt) file or
			' the edat2 file is not open and then try the experiment run again.
			If FileExists(strFilenameEDAT) Then Kill strFilenameEDAT
			If FileExists(c.DataFile.Filename) Then Kill c.DataFile.Filename
		End If
	End If

	' Set defaults for RandomSeed and GroupNumber if StartupInfo did not assign their values
	If Not c.AttribExists("RandomSeed") Then c.SetAttrib "RandomSeed", PRNG.GetSeed()
	If Not c.AttribExists("Group") Then c.SetAttrib "Group", "1"

	'Set the random seed
	Randomize CLng(c.GetAttrib("RandomSeed"))

	' Initialize Experiment Advisor Properties
	Rte.ExperimentAdvisor.LoadProperties
	If c.AttribExists("Rte.ExperimentAdvisor.Enabled") Then Rte.ExperimentAdvisor.Enabled = CLogical(c.GetAttrib("Rte.ExperimentAdvisor.Enabled"))
	If c.AttribExists("Rte.ExperimentAdvisor.Filename") Then Rte.ExperimentAdvisor.Filename = CStr(c.GetAttrib("Rte.ExperimentAdvisor.Filename"))


	Dim nPriority As Long
	'Priority for init routines
	nPriority = 3

	'Determine if the priority should use the override value
	If c.AttribExists("SetOSThreadPriority.Init.Override") Then
		nPriority = c.GetAttrib("SetOSThreadPriority.Init.Override")
	End If

	'Update E-Prime Priority for INIT routines
	SetOSThreadPriority nPriority

	' Initialize all system devices, packages, and objects
	InitDevices c
	InitPackages c
	InitObjects c

	'Priority for start of experiment
	nPriority = -1

	'Determine if the priority should use the override value
	If c.AttribExists("SetOSThreadPriority.Override") Then
		nPriority = c.GetAttrib("SetOSThreadPriority.Override")
	End If

	'Update E-Prime Priority for start of experiment
	SetOSThreadPriority nPriority

	'Disable System power save mode
	Rte.PreventSystemIdle = True

	If CLng(c.GetAttrib("Subject")) < 0 Then
		Rte.AbortExperiment 12102, ebUCase_S & ebLCase_u & ebLCase_b & ebLCase_j & ebLCase_e & ebLCase_c & ebLCase_t & ebSpace & ebLCase_c & ebLCase_a & ebLCase_n & ebLCase_n & ebLCase_o & ebLCase_t & ebSpace & ebLCase_b & ebLCase_e & ebSpace & ebLCase_l & ebLCase_e & ebLCase_s & ebLCase_s & ebSpace & ebLCase_t & ebLCase_h & ebLCase_a & ebLCase_n & ebSpace & ebDigit_0 & ebDot
	End If

	If CLng(c.GetAttrib("Session")) < 1 Then
		Rte.AbortExperiment 12103, ebUCase_S & ebLCase_e & ebLCase_s & ebLCase_s & ebLCase_i & ebLCase_o & ebLCase_n & ebSpace & ebLCase_c & ebLCase_a & ebLCase_n & ebLCase_n & ebLCase_o & ebLCase_t & ebSpace & ebLCase_b & ebLCase_e & ebSpace & ebLCase_l & ebLCase_e & ebLCase_s & ebLCase_s & ebSpace & ebLCase_t & ebLCase_h & ebLCase_a & ebLCase_n & ebSpace & ebDigit_1 & ebDot
	End If

	' If we are logging data, then open the datafile
	If CLng(c.GetAttrib("Subject")) <> 0 Then
		c.DataFile.Open
		c.LogHeader
	End If


	'Setup the DataFile.BaseName attribute
	c.SetAttrib "DataFile.BaseName", Replace(c.DataFile.Filename, ".txt", ebEmptyText)

	' Log clock timing information
	c.SetAttrib "Clock.Information", Clock.Information

	' Log E-Studio version
	c.SetAttrib "StudioVersion", "2.0.10.252"

	' Log runtime version.
	c.SetAttrib "RuntimeVersion", Rte.Version.Major & ebDot & Rte.Version.Minor & ebDot & Rte.Version.Internal & ebDot & Rte.Version.Build
	c.SetAttrib "RuntimeVersionExpected", 2 & ebDot & 0 & ebDot & 10 & ebDot & 356
	c.SetAttrib "RuntimeCapabilities", ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_f & ebLCase_e & ebLCase_s & ebLCase_s & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_a & ebLCase_l

	' Log experiment version
	c.SetAttrib "ExperimentVersion", "1.0.0.325"

	' ExperimentStart
	 Rte.ExperimentStart
	' Start the running of the Experiment
	SessionProc.Run c
	' ExperimentFinish
	 Rte.ExperimentFinish

	' Clean up the context and close the datafile
	If CLng(c.GetAttrib("Subject")) <> 0 Then
		Dim nDataFileConvertProgress As Long
		nDataFileConvertProgress = ebProgressSimple
		If c.AttribExists("DataFile.ConvertProgress") Then nDataFileConvertProgress = CLng(c.GetAttrib("DataFile.ConvertProgress"))
		c.DataFile.Close
		' Attempt to convert the recovery file into a data file
		Dim nConvert As Long
		nConvert = c.DataFile.Convert(nDataFileConvertProgress)

		If nConvert = 0 Then
			' Settings in E-Studio are set to not remove E-Recovery file
		Else
			' The datafile failed to convert!
			MsgBox "ERROR: The datafile did not convert!\nFILE: " & c.DataFile.Filename & "\n\nIt is recommended that you recover your data with the E-Recovery utility"
			MsgBox c.DataFile.GetLastErrorMessage()
		End If
	End If
ExperimentFinish:

	UnInitObjects

	UnInitPackages
	UnInitDevices

	UnInitGlobals

	' Experiment Advisor Report Generation
	If Rte.ExperimentAdvisor.Enabled = True Then
		If Len(Rte.ExperimentAdvisor.Filename) = 0 Then Rte.ExperimentAdvisor.Filename = Replace(c.DataFile.Filename, ".txt", "-ExperimentAdvisorReport.xml")
		Rte.ExperimentAdvisor.GenerateReport


	End If


ExperimentAbort:

	' Clean up the context
	c.PopFrame
	Set c = Nothing
	Set ebContext = Nothing

	DestroyDefaultPort

End Sub
